# EasySafe Cryptography Overview

###### Author

Jonas Acres
jonas@acrescrypto.com

###### Version
Revision PRE-02, 2019-01-05

This document is currently in an unstable draft status, and reflects pre-release software. It is therefore subject to change.

###### Intellectual Property

This work is licensed under a Creative Commons Attribution 4.0 International License. 
(License: https://creativecommons.org/licenses/by/4.0/)

The author is not aware of any patents encumbering the methods described in this document.

## Purpose

EasySafe is a distributed, encrypted filesystem. The filesystem can be read and written to based on knowledge of a passphrase. Peers hosting the filesystem can also be located on a decentralized network using the passphrase.

This document explains the cryptography used to encrypt files, locate peers and communicate with them.

## Conventions

### Concatenation operator

The `||` operator denotes concatenation. Example:

`"abc" || "def"   // "abcdef"`

When the `||` operator is applied to an integer, the integer is to be serialized in big-endian byte order. The size of the integer field in bits is explicitly specified in all cases. For example:

```
x = 1234
y = "abc" || x(32)   // y = { 'a', 'b', 'c', 0x00, 0x00, 0x12, 0x34 }
```

### Size operator

The operation `|x|` on a byte string `x` returns the number of bytes in `x`. Example:

```
x = "abc"    // |x| = 3
```

### Bitshift operator

The operation `x << y` on a bit string `x` causes `x` to be shifted left by `y` bits. The `y` least significant bits of the result are set to 0.

### XOR operator

The operation `x ^ y` is understood to be equivalent to `x XOR y`.

### Standard crypto functions

The cryptographic functions used in EasySafe:

| Name | Algorithm | Length (bits) |
|------|--------------------|--------------|
| Hash(data) | Blake2b            | 512         
| FastHash(key, data) | SipHash-2-4 | 64
| HMAC(key, data)| RFC 2104           | 
| HKDF(key, data) | RFC 5869     | 
| SymmetricEncrypt(key, iv, plaintext) | ChaCha20 | 256 key / 96 nonce
| SymmetricEncryptAEAD(key, iv, plaintext) | ChaCha20-Poly1305 | 256 key / 96 nonce / 128 tag
| AsymmetricSharedSecret(privateKey, publicKey) | X25519 | 256
| AsymmetricSign(privateKey, data) | Ed25519 | 512
| AsymmetricVerify(publicKey, signature, data) | Ed25519 | 256
| AsymmetricDerivePublic(privateKey) | Ed25519 | 256
| PBKDF(passphrase) | Argon2 | 256

#### Argon2 settings

The parameters chosen for all Argon2 operations are as follows:

| Argon2 Setting | Value                  |
|----------------|------------------------|
| mode           | Argon2d                |
| salt           | "easysafe-argon2-salt" |
| parallelism    | 16 threads             |
| tagLength      | 256 bits               |
| memorySize     | 1 GiB                  |
| iterations     | 40                     |
| version        | 13                     |

## Basic constants
The following constants will be referred to by name throughout the document:

| Constant name    | Value | Unit | Description
|------------------|-------|------|----|
| HASH_LEN         | 64              | bytes | Output length of Hash() function
| SYM_KEY_LEN      | 32              | bytes | Symmetric key size
| SYM_IV_LEN       | 16              | bytes | Symmetric initialization vector size in unauthenticated mode (equivalent to block size)
| SYM_AEAD_IV_LEN  | 16              | bytes | Symmetric initialization vector size in authenticated mode
| SYM_AEAD_TAG_LEN | 16              | bytes | Tag size for symmetric encryption in authenticated mode
| ASYM_SIG_LEN     | 64              | bytes | Output length of AsymmetricSign() function
| PAGE_SIZE        | 65536 (default) | bytes | Configurable fixed page size for filesystem.


## Additional functions

The following functions are referred to in this document. Their function is expressed here in pseudocode:

```
ASSERT(booleanValue)
  // Abort processing if booleanValue is not true.
```

```
RandomBytes(length)
  // return 'length' randomly generated bytes from a CSPRNG or TRNG
```

```
zero(n): // return n bytes all set to 0
  return { 0x00, 0x00, ..., 0x00 } // n bytes total

example:
  zero(4) = { 0x00, 0x00, 0x00, 0x00 }
```

```
int(data) // deserialize bytes as big-endian integer

example:
  int({0x00, 0x00, 0x12, 0x34}) // 0x1234
```

```
pad(data, size):
  return |data|(32) || data || zero(size - |data|)
```

```
unpad(data):
  len = int(data[0 ... 4])
  return data[4 ... 4 + len]
```

```
deriveSubkey(parentKey, name, salt):
  return HKDF(ikm=parentKey, length=SYM_KEY_LEN, salt=name || salt, info="easysafe-subkey");
```

### Tagged encryption

The following methodology is used to perform the `taggedEncrypt` function, used several times in this document.

#### Arguments

The `taggedEncrypt` function has the following arguments:
```
taggedEncrypt(symRootKey, authKey, signPrivateKey, plaintext)
```

| Argument | Description
|--|--|
| SymRootKey | Key material used to derive encryption key
| KeySalt | Additional salt to use in encryption key derivation
| AuthKey | Key used to authenticate resultant ciphertext
| SignPrivateKey | Private key used to sign resultant ciphertext
| Plaintext | Plaintext to be encrypted

#### Result

The `taggedEncrypt` function produces a two-tuple of the form (tag, ciphertext):

| Result | Description
|-|-|
| Tag | Authenticated hash of ciphertext using supplied `AuthKey` |
| SignedCiphertext | Signed ciphertext, encrypted using material from `SymRootKey` and signed with `SignPrivateKey`

#### Methodology

##### Plaintext padding
The plaintext is first padded to the fixed page size.

```
PaddedPlaintext = pad(data=Plaintext, len=PAGE_LEN) // must have: |Plaintext| <= PAGE_LEN
```

##### Key derivation
File-specific keys are derived based on the

```
keyMaterial = HDKF(ikm=KeySalt, length=2*SYM_KEY_LENGTH, salt=symRootKey, info="tagged-encryption-key-material")
TextKey = keyMaterial[0 ... SYM_KEY_LENGTH]
SaltKey = keyMaterial[SYM_KEY_LENGTH ... 2*SYM_KEY_LENGTH]
```

##### File salt
A plaintext-specific salt is derived using the `SaltKey`:

```
PTSalt = HMAC(key=SaltKey, data=PaddedPlaintext)
```

##### Encryption key derivation
The `PTSalt` is used to derive an encryption key:

```
EncryptionKey = deriveSubkey(parentKey=symRootKey, name="tagged-encryption-key", salt=PTSalt)
```

##### Unsigned ciphertext
The encryption key is used to produce unauthenticated ciphertext:

```
RawCiphertext = SymmetricEncrypt(key=EncryptionKey, nonce=zeros(SYM_IV_LEN), plaintext=PaddedPlaintext)
```

##### Signature
The raw ciphertext is signed and combined with the `PTSalt` to produce the final ciphertext:

```
signature = AsymmetricSign(key=SignPrivateKey, data=RawCiphertext)
SignedCiphertext = PTSalt || RawCiphertext || signature
```

##### Tag
The ciphertext is authenticated using the auth key.

```
Tag = HMAC(key=authKey, data=Ciphertext)
```

# Filesystem

## Key derivations
Every EasySafe filesystem is defined by a read passphrase and a write passphrase. By default, these passphrases are identical, but this may be overridden by the user.

```
ReadPassphrase // given by user
WritePassphrase // given by user; defaults to ReadPassphrase

RootKey = PBKDF(ReadPassphrase)
WritePrivateKey = PBKDF(WritePassphrase)
WritePublicKey = AsymmetricDerivePublic(WritePrivateKey)
SeedKey = deriveSubkey(parentKey=RootKey, name="SeedKey", salt=zeros(0))
```

Possession of these keys acts as authorization for various tasks.

| Key | Possessor can... |
|-----|-----|
| WritePublicKey | ...verify data belongs to filesystem |
| SeedKey | ...participate in p2p network for filesystem
| RootKey | ...read filesystem contents |
| WritePrivateKey | ...add to filesystem |

It is presumed that a user given the `WritePrivateKey` also has knowledge of the `RootKey`. The converse is not true. A user given the `RootKey` is not presumed to have knowledge of the `WritePrivateKey`, unless the read and write passphrases are identical.

#### FS Key
Every EasySafe filesystem has an additional 256-bit key referred to as the `FSKey`. This key is stored in the configuration file, encrypted using the `RootKey`. By default, the `FSKey` is equal to the `RootKey`. In non-default filesystems (explained below), the `FSKey` is randomly generated.

### Seed-only peers
A peer possessing knowledge of the `SeedKey`, but not the `RootKey`, `FSKey` or `WritePrivateKey`, is referred to as a "seed-only peer." These peers are able to participate in the peer-to-peer network to send and receive encrypted data, and possess sufficient information to authenticate that date. However, these peers are unable to read the contents of the encrypted filesystem.

## Configuration file
### Default filesystems
Each filesystem has a configuration file containing various parameters. For instance, the write passphrase can optionally be chosen independently of the read passphrase. There are default values for each configuration parameter. When the defaults are chosen for all parameters, the configuration file is deterministic from the passphrase. Such a filesystem is referred to as a "default filesystem." These filesystems can be located in the decentralized network solely with knowledge of their passphrase.

### Configuration layout

The configuration file is laid out as follows:

|         |
|---------|
| Version hash |
| Salt         |
| Seed ciphertext |
| Secure ciphertext |
| Padding |
| Signature |

#### Version hash

The version hash is produced as follows:

```
VersionHash = HMAC(key=SeedRoot, data="easysafe-version:0")
```

#### Salt

The salt is generated using an authenticated hash of the following:

| SaltInput |
|-|
| Seed Section Plaintext Length (16 bits) |
| Seed Section Plaintext |
| Secure Section Plaintext Length (16 bits) |
| Secure Section Plaintext |

This information is then authenticated to produce the salt:
```
Salt = HMAC(key=SeedKey, data=SaltInput)
```

#### Seed ciphertext
The plaintext structure of the seed section is beyond the scope of this document. It includes `PAGE_SIZE` and `WritePublicKey`, as well as any other filesystem parameters that must be known to parties possessing the `SeedKey`.

The seed ciphertext key is derived as follows:

```
SeedCiphertextKey = deriveSubey(parentKey=SeedKey, name="SeedCiphertextKey", salt=VersionHash || Salt)
```

The key is then used to produce the secure ciphertext:

```
SeedCiphertext = SymmetricEncrypt(key=SeedCiphertextKey, nonce=zeros(SYM_IV_LEN), data=SeedPlaintext)
```

#### Secure ciphertext
The plaintext structure of the secure section is beyond the scope of this document. The secure section includes the `FSKey`, and any filesystem parameters that should be known only to holders of the read passphrase. The secure ciphertext key is derived as follows:

```
SecureCiphertextKey = deriveSubey(parentKey=RootKey, name="SecureCiphertextKey", salt=VersionHash || Salt || SeedCiphertext)
```

The key is then used to produce the secure ciphertext:

```
SecureCiphertext = SymmetricEncrypt(key=SecureCiphertextKey, nonce=zeros(SYM_IV_LEN), data=SecurePlaintext)
```

#### Padding

The padding section ensures that the overall length of the configuration file is equal to `PAGE_SIZE + ASYM_SIG_LEN`. Thus, it has a length of:

```
PaddingLen = PAGE_SIZE + ASYM_SIG_LEN - |VersionHash| - |Salt| - |SeedCiphertext| - |SecureCiphertext|
```

The padding may take any value, subject to the requirement that it appear statistically indistinguishable from random to a party that does not have knowledge of the read passphrase. By default, the padding is constructed deterministically as follows:

```
paddingKey = deriveSubkey(parentKey=RootKey, name="PaddingKey", salt=VersionHash || Salt || SeedCiphertext || SecureCiphertext)
Padding = SymmetricEncrypt(key=paddingKey, nonce=zeros(SYM_IV_LEN), data=zeros(PaddingLen))
```

#### Signature
A public key signature is calculated over the preceding sections using the `WritePrivateKey` as follows:

```
unsignedFile = VersionHash || Salt || SeedCiphertext || SecureCiphertext || Padding
Signature = AsymmetricSign(key=WritePrivateKey, data=unsignedFile)
```

#### Assembled configuration file
The above sections are concatenated together to form the completed configuration file:

```
ConfigFile = VersionHash || Salt || SeedCiphertext || SecureCiphertext || Padding || Signature
```

### FSID
A unique 512-bit identifier is formed from the configuration file. This identifier is called the `FSID`, and is used to distinguish one filesystem from another.

The FSID is composed of two fields:

| Field | Length |
|-|-|
| Prefix | 32 bytes
| Suffix | 32 bytes |

#### Prefix
The prefix is calculated using the `SeedKey` and `ConfigFile` as follows:

```
Prefix = HMAC(key=SeedKey, data=ConfigFile)
```

#### Suffix
The suffix is an authenticated ciphertext containing the `PAGE_SIZE`:

```
suffixData = PAGE_SIZE(64) || zeros(8) // 16 bytes
suffixKey = deriveSubkey(parentKey=SeedKey, name="FSIDSuffixKey", salt=Prefix)
suffix = SymmetricEncryptAEAD(key=suffixKey, nonce=zeros(SYM_IV_LEN), data=suffixData)
```

Including the resulting AEAD tag, the suffix is 32 bytes in length.

#### Assembled FSID
The FSID is the concatenation of the prefix and suffix:

```
FSID = prefix || suffix
```

#### Configuration file path
The path used for the configuration file in storage is derived from the FSID.

```
pathHash = HMAC(key=SeedKey, data=FSID)
ConfigPath = hashpath(pathHash)
```

The configuration file is written to the path specified by `ConfigPath`.

## File storage

### Inode table
Every file in an filesystem is indexed within an inode. The inode contains basic information beyond the scope of this document, similar to that described in a POSIX `stat_t` structure. Additionally, the inode contains a 64-bit randomly-generated `distinguisher` field which is constant for the life of the file, and a RefTag.

Inode contents include:

| Field | Description |
|-------|-------------|
| stat  | POSIX `stat_t`-like data structure containing file metadata
| distinguisher | Random 64-bit integer; constant for lifetime of file
| reftag | RefTag object, described below. Allows retrieval of file.

The inode table is stored in the same manner as any other file in the filesystem, described below. The inode table has a fixed `distinguisher` of zero. The `reftag` of the inode table is expressed as a `RevisionTag`, described below.

### RefTags

A RefTag is an identifier allowing retrieval of a file from a filesystem. It is structured as follows:

| Field | Size | Description
|-------|--------|----|
| tag   | HASH_LEN | Context-dependent on refType
| numPages | 8 | Number of pages in file. Does not include page tree chunks.
| refType | 1 | Reference type, determines meaning of `tag` field. See below for acceptable values.
| reserved | 3 | Reserved for future use.

The `refType` field takes on values from the following table:

| Value | Symbol | tag field semantics | Used when...
|-------|--------|---------------------|----|
| 0     | REF_TYPE_IMMEDIATE | Tag field contains literal file contents, zero-padded to HASH_LEN | File size < HASH_LEN
| 1     | REF_TYPE_INDIRECT | Tag field contains tag of only page in file. | HashLen <= File size <= PageSize
| 2     | REF_TYPE_2INDIRECT | Tag field contains tag of root page tree chunk. | File size > PageSize

The "Page" and "Page Tree" structures are described below.

### Pages
#### Plaintext structure
Files are divded into individual pages of fixed length for storage. The plaintext of each page is structured as follows:

| Field | Length (bytes)
|---------|---|
| length | 4 | Length of data in page
| data | length | Plaintext from file
| padding | PAGE_SIZE - length | Null padding to read fixed length

The `length` field is `PAGE_SIZE` or the number of bytes in the final page of the file, whichever is lesser.

#### Ciphertext
The plaintext is encrypted, resulting in a ciphertext and page tag.

```
FSID // From filesystem
Distinguisher // From inode
PageNum // Index of page into file
PagePlaintext // Constructed per table above

pageKey = deriveSubkey(parentKey=FSKey, name="Page", salt=FSID || Distinguisher(64) || PageNum(16))
PageTag, PageCiphertext = taggedEncrypt(symKey=pageKey, authKey=SeedRoot, signPrivateKey=WritePrivateKey, plaintext=PagePlaintext)
```

#### Storage
The page is stored at a location determined by its tag.

```
PagePath = hashpath(PageTag)
```

#### RefTag calculation

If a file consists of exactly one page, then the resulting tag of that page is used to create the RefTag stored in the file's inode, with type `REF_TYPE_INDIRECT`. Otherwise, the page tag is stored inside of a page tree, defined below.

### Page trees
Individual pages can only be read if their page tag is known. When a file consists of only a single tag, the tag is stored directly in the inode table for the file. For files containing multiple tags, the tags are stored in a B-tree structure known as a "page tree". Each node of the page tree is known as a "page tree chunk."

#### Page tree chunk plaintext

Each chunk is a list of tags. For branch nodes, these tags reflect the tags of the node's children. For leaf nodes, these tags reflect page tags belonging to the file.

| Chunk |
|---|
| tag0 |
| tag1 |
| ... |

The chunk plaintext is padded so that its total length is `PAGE_SIZE`.

#### Page tree chunk ciphertext

```
FSID // From filesystem
Distinguisher // From inode
ChunkNum // Index of chunk in tree
ChunkPlaintext // Constructed per table above

chunkKey = deriveSubkey(parentKey=FSKey, name="Chunk", salt=FSID || Distinguisher(64) || ChunkNum(16))
chunkTag, PageCiphertext = taggedEncrypt(symKey=chunkKey, authKey=SeedRoot, signPrivateKey=WritePrivateKey, plaintext=ChunkPlaintext)
```

#### Storage
The chunk is stored at a location determined by its tag.

```
ChunkPath = hashpath(ChunkTag)
```

#### RefTag calculation
When page trees are used, the file reftag is constructed with type `REF_TYPE_2INDIRECT` using the tag of the root chunk (that is, the chunk with index 0).

### RevisionTags

A RevisionTag provides an entry point into the filesystem, similar to a git commit hash. A RevisionTag is not a hash, and contains readable information. To prevent seed-only peers from learning information about the structure of the filesystem by observing RevisionTags, the content of the RevisionTag is obfuscated.

#### Plaintext

The plaintext of the RevisionTag contains the following fields:

| Field | Length (bytes) | Description |
|-------|----------------|-------------|
| refTag | HASH_LEN + 12 | RefTag produced by inode table |
| parentTag | 8 | First 8 bytes of RevisionTag of parent[1]
| height | 64 | 1 + height of parent |

[1] If a revision has multiple parents, the parentTag is calculated by hashing the concationation of the parent revtags in sorted order. If a revision has no parents, the blank RevisionTag is used.

[2] If a revision has multiple parents, the greatest parent height is used. If a revision has no parents, the height is set to 1.

#### Obfuscator

An obfuscator is derived from the plaintext as follows:

```
Obfuscator = HKDF(ikm=plaintext, length=16, salt=FSKey, info="revision-tag-obfuscator")
```

The obfuscator derives an obfuscation key:

```
ObfuscationKey = deriveSubkey(parentKey=FSKey, name="obfuscation-key", salt=Obfuscator)
```

##### Obfuscator collisions
The obfuscator is derived deterministically from the plaintext to ensure that a given RefTag always produces the same RevisionTag. The obfuscator is again combined with the `FSKey` to ensure that only peers possessing knowledge of the `FSKey` can decipher the RefTag.

There is a tradeoff between the length of the obfuscator (and therefore efficiency of representation), and the probability of two RevisionTags producing identical obfuscators. With a 128-bit obfuscator, this happens on average once per 2^64 RevisionTags. When RevisionTags share a common obfuscator, their confidentiality is lost. This will allow the adversary to learn the refTag, parentTag and height. In turn, this provides the adversary with at least one page file whose `Distinguisher` field is known, simplifying brute force attacks against the `FSKey`. This capability is modeled as the `InodeTableOracle` in the threat model later in this document.

If a filesystem produces a new revision every nanosecond, it will take an average of over 584 years to produce such a collision. This is deemed acceptable for most use cases. Nevertheless, the complexity is low enough that this operation is referred to as "obfuscation" rather than "encryption."

#### Ciphertext
The obfuscation key is used to encrypt the plaintext:

```
RevTagPlaintext // constructed according to table above
RevisionTagCiphertext = SymmetricEncrypt(key=ObfuscationKey, iv=zeros(SYM_IV_LEN), data=RevTagPlaintext)
```

#### Signature
The resulting ciphertext is then signed using the `WritePrivateKey`. This is done to allow seed-only peers to authenticate RevisionTags without knowledge of the `FSKey`.

```
RevisionTagSignature = AsymmetricSign(key=WritePrivateKey, data=RevisionTagCiphertext)
```

#### Assembled RevisionTag
The obfuscator, ciphertext and signature are combined to produce the RevisionTag:

```
RevisionTag = obfuscator || ciphertext || signature
```

#### Revision tag distribution
RevisionTags are stored locally as entry points into the filesystem. Additionally, each filesystem revision contains a special file referred to as the "Revision Info" which contains a list of the RefTags of each parent revision.

RevisionTags are shared on the peer-to-peer network, including to seed-only peers.

## Distributed Hash Table

EasySafe allows filesystem peers to discover one another by means of a distributed hash table (DHT). This DHT allows peers with knowledge of seed key to discover "advertisements" listing FSIDs and connection information (such as IP address and port number) for peers sharing filesystems matching that seed key.

### DHT protocol
The particulars of the DHT protocol are provided in a separate document, entitled "EasySafe Network Specification." Discussion in the present document is limited to the cryptographic aspects of this protocol.

As a simplification, the DHT can be understood as a service providing the following functions:

| Function | Result | Description
|----------|--------|-------------
| DHTLookup(temporalSeedId) | Zero or more Advertisements | Locate Advertisements for connectable peers sharing a given seed ID
| DHTSet(peer, temporalSeedId, ad) | None | Request a remote peer to store an advertisement for a given seed ID

### Temporal seed IDs
The temporal seed ID is a time-dependent derivative of the `SeedKey`.

```
// EpochSeconds = # seconds elapsed since 1970-01-01 00:00:00 UTC
timeslice = floor(EpochSeconds / (60*60*3))
temporalSeedId = deriveSubkey(rootKey=SeedKey, name="temporal-seed-key", salt=timeslice(64))
```

The temporal seed IDs are designed to rotate every 3 hours. This is done so that Sybil attacks against an ID will require an ongoing investment of effort, and to limit the duration for which DHT peers can observe the number of lookups for a given ID.

### Message-level cryptography
Each DHT peer has a static X25519 keypair used to encrypt messages. Message plaintexts are encrypted using key material derived from the shared secret produced by the static keys of the two parties. Because these keys are static, a compromise of a peer's private key allows an adversary retroactive decryption of any previous messages sent during the lifespan of that key.

Messages are encrypted and serialized as follows.

#### Parameters

The following variables are defined prior to encrypting the DHT message:
```
NetworkID // fixed constant, specific to the DHT
PayloadPlaintext // raw plaintext of a DHT protocol message
RemotePubKey // X25519 static public key of the receiving peer
LocalPubKey // X25519 static public key of the local peer
LocalPrivKey // X25519 static private key of the local peer
```

#### Per-message salt

A 16-byte `MsgSalt` field is generated for each message. This salt must meet the following requirements:

1. The (`RemotePubKey`, `LocalPubKey`, `MsgSalt`) tuple must be unique, with very high probability.
2. `MsgSalt` must be indistinguishable from random to the casual observer.
3. `MsgSalt` must not reveal any information about the payload of the message to a party that does not possess either `LocalPrivKey` or the private key corresponding to `RemotePubKey`.

In the present implementation, `MsgSalt` is generated by a CSPRNG.

#### Obfuscation key

The `LocalPubKey` field is obfuscated using a key derived from `NetworkID`, `MsgSalt` and `RemotePubKey`. This is done to prevent a casual observer from distinguishing any part of the transmitted DHT message from random.

```
ObfKey = HKDF(ikm=RemotePubKey, length=SYM_KEY_LEN, salt=NetworkID || MsgSalt, info="easysafe-dht-obfkey")
```

The key obfuscation is done by encrypting the `localPubKey` with the `ObfKey`:

```
ObfuscatedPubKey = SymmetricEncrypt(key=ObfKey, iv=zeros(SYM_IV_LEN), plaintext=LocalPubKey)
```

#### Message key
The message key is derived from a combination of the shared secret derived by the Diffie-Hellman operation of the `LocalPrivKey` with the `RemotePubKey`, with various extra salting parameters.

```
extraSalt = NetworkId || LocalPubKey || RemotePubKey || MsgSalt || ObfuscatedPubKey
dhSecret = DH(LocalPrivKey, RemotePubKey)
MsgKey = HKDF(ikm=dhSecret, length=SYM_KEY_LEN, salt=extraSalt, info="easysafe-dht-msgkey")
```

#### Message ciphertext
The DHT message payload is then encrypted using the derived `MsgKey`.

```
MsgCiphertext = SymmetricEncryptAEAD(key=messageKey, iv=zeros(SYM_IV_LEN), plaintext=plaintext)
```

#### Assembled message
The `MsgSalt`, `ObfuscatedPubKey` and `MsgCiphertext` are combined to form the completed DHT message.

```
DhtMsg = MsgSalt || ObfuscatedPubKey || MsgCiphertext
```

The `DhtMsg` is then transmitted to the remote peer.

### Lookup tokens
When performing the `DHTLookup` operation, each individual request contains a lookup token specific to the remote peer. This token is constructed as follows:

```
NetworkID // fixed constant, specific to the DHT
RemotePubKey // X25519 static public key of the receiving peer
TemporalSeedId // Temporal seed ID used as argument to DHTLookup

lookupKey = deriveSubkey(rootKey=SeedRoot, name="dht-lookup", salt=NetworkID)
LookupToken = HMAC(key=lookupKey, TemporalSeedId || RemotePubKey)
```

Because the `LookupToken` depends on the remote peer's public key, the token is specific to each peer. When performing a `DHTSet` operation, requestors include the `LookupToken` for the remote peer with the advertisement to be stored. The `LookupToken` is also included in `DHTLookup` requests, and the remote peer will only respond with advertisements stored with the same token. This prevents a peer from performing `DHTLookup` operations on temporal seed IDs harvested from `DHTLookup` operations that the peer has received.

### Advertisement content
Advertisements are structured as follows:

| Advertisement |
|-|
| Public mutable section (unencrypted) |
| Public immutable section (unencrypted) |
| Private section (encrypted) |

#### Public mutable section
The public mutable section contains plaintext information that may be altered by the peer storing the advertisement. It contains:

| Public mutable section |
|-|
| IP address (string)

This section is mutable so that the storing peer can set the IP address to the observed IP address of the sender, as a means to overcome scenarios in network address translation where the sender may not know their own public IP address. The storing peer must also be able to ensure that the advertisement lists the sender's actual IP address, as a means of discouraging denial of service attacks.

#### Public immutable section
The public immutable section contains plaintext information that may not be altered by the peer storing the advertisement.

| Public immutable section |
|-|
| AdSalt (64-bit) |

##### Salt
The `AdSalt` is a random 64-bit value. It must be unique to the advertisement. Storing peers reject any advertisement with a salt matching one that they already possess for a given `LookupToken`.

#### Private section

The private section is encrypted using a key derived from the `LookupToken`, `AdSalt` and `SeedKey`.

| Private section plaintext |
|---|
| Port (16-bit)
| FSID
| Public static key

Advertisements also contain an encrypted FSID field, calculated as follows:

##### Key derivation

The private section is encrypted with a key derived as follows:

```
PrivateSectionKey = deriveKey(rootKey=SeedKey, name="dht-advertisement", salt=LookupToken || AdSalt)
```

##### Ciphertext

The private section ciphertext is produced by encrypting the plaintext with the `PrivateSectionKey`:

```
PrivateSectionPlaintext // constructed per table above

PrivateSectionCiphertext = symmetricEncryptAEAD(key=PrivateSectionkey, nonce=zeros(SYM_IV_LEN), plaintext=PrivateSectionPlaintext)
```

#### Assembled advertisement

The completed advertisement is assembled by concatenating the `PublicMutableSection`, `PublicImmutableSection` and `PrivateSection`:

```
AdText = PublicMutableSection || PublicImmutableSection || PrivateSection
```

## Swarming
EasySafe peers participate in a peer-to-peer swarm to share filesystem data.

### Swarming protocol
As with the DHT protocol, the particulars of the swarming protocol are not considered in this document, beyond what is needed to exmaine its cryptographic aspects.

### Handshaking

Handshaking and message encryption follow the standards of the Noise specification, as of Revision 34.[TODO cite] The protocol name is `Noise_XKpsk4_25519_ChaChaPoly_BLAKE2b`.

In Noise notation, the handshake pattern is expressed as follows:
```
// PSK is FSID
// Responder static key learned by initiator from DHT ad
// | denotes message payload, which is to be encrypted per Noise specification
XKpsk4:
  <- s
   ...
  -> e, es
  <- e, ee
  -> s, se | additionalA
  <- psk   | additionalB
```

##### XKpsk4 designation
The Noise specification does not contain a "XKpsk4" pattern. This key exchange follows the standard XKpsk3 pattern, with the exception that the psk is moved to a new fourth round.

This is because the responder may be listening for multiple filesystems using the same port and public static key. Since the FSID is used as a pre-shared key, the responder must receive information from the requestor in order to determine which FSID to use. The requestor cannot safely transmit this information until the payload of round 3 (the `additionalA` section, described below).

In the standard "XKpsk3" pattern, the `psk` token would have been processed prior to encrypting `additionalA`, meaning the responder would be unable to determine which PSK to use. Therefore the `psk` token is delayed until the next round.

##### Symmetric obfuscation of ephemeral public key
During the handshake, the initiator's public ephemeral key is transmitted in the clear. Ed25519 public keys are distinguishable from random. To prevent a casual observer from distinguishing EasySafe traffic from random, the initiator's public ephemeral key is obfuscated using a key derived from the responder's public static key:

```
  ResponderPublicStaticKey // public static key belonging to responder; known to requestor from ad
  InitiatorPublicEphemeralKey // public ephemeral key belonging to initiator
  
  random = RNG(32)
  obfKey = deriveSubkey(parentKey=ResponderPublicStaticKey, name="handshake-ephemeral-key-obfuscation", salt=random)
  ObfuscatedEphemeralKey = random || SymmetricEncryptAEAD(key=obfKey, iv=zeros(SYM_IV_LEN), data=InitiatorPublicEphemeralKey)
```

The `ObfuscatedEphemeralKey` is what is transmitted when processing the `e` token of round 1 of the Noise handshake.

##### Additional key material derivation
Length obfuscation (explained below) requires the derivation of additional key material during handshaking. This is done via a modification to the `Split()` function of Noise, as defined in section 5.2 of the specification:

```
Split(): Returns a pair of CipherState objects for encrypting transport messages. Executes the following steps, where zerolen is a zero-length byte sequence:

    Sets temp_k1, temp_k2 = HKDF(ck, zerolen, 2).
    If HASHLEN is 64, then truncates temp_k1 and temp_k2 to 32 bytes.
    Creates two new CipherState objects c1 and c2.
    Calls c1.InitializeKey(temp_k1) and c2.InitializeKey(temp_k2).
    Returns the pair (c1, c2).
```

The HKDF call is changed to produce 3 outputs, the last of which is termed `akm_root`. The resulting function is termed `ModifiedSplit()` and is specified here:

```
ModifiedSplit(): Returns a pair of CipherState objects for encrypting transport messages. Executes the following steps, where zerolen is a zero-length byte sequence:

    Sets temp_k1, temp_k2, ask_root = HKDF(ck, zerolen, 3).
    If HASHLEN is 64, then truncates temp_k1 and temp_k2 to 32 bytes.
    Creates two new CipherState objects c1 and c2.
    Calls c1.InitializeKey(temp_k1) and c2.InitializeKey(temp_k2).
    Returns (c1, c2, ask_root).
```

`ask_root` is not the same kind of object as `c1` and `c2`. The purpose of this notation is simply to make clear that `ask_root` is an additional shared key calculated at the conclusion of the handshake, derived in the same HKDF operation as the key material used to create `c1` and `c2`.

##### Ciphertext length obfuscation keys
The `ask_root` is used to initialize four variables used for length obfuscation.

```
AskRoot // ask_root from ModifiedSplit() as described above

keyRaw = HKDF(ikm=askRoot, len=2*FAST_HASH_LEN, salt=zeros(0), info="obfuscated-length-key")
ivRaw = HKDF(ikm=askRoot, len=16, salt=zeros(0), info="obfuscated-length-iv")

LenKeyA = keyRaw[0 ... FAST_HASH_LEN]
LenKeyB = keyRaw[FAST_HASH_LEN ... 2*FAST_HASH_LEN]

LenIvA = ivRaw[0 ... 8]
LenIvB = ivRaw[8 ... 16]
```

The `LenKeyA`, `LenKeyB`, `LenIvA` and `LenIvB` fields are used in the Ciphertext Length Obfuscation section below.

##### Payloads
The additional data sections `additionalA` and `additionalB` are constructed as follows.

The initiator performs the following operations to calculate `additionalA` at the end of round 3:
```
// HA refers to Noise handshake hash after the "se" symbol of round 3 has been processed
// FSID is FSID belonging to the filesystem initiator intends to share with responder

idHash = HMAC(key=HA, data=FSID)
proofA = calculateProof(0, HA)

additionalA = JSON({ idHash:idHash, proof:proofA }) || zeros(1)
```

The responder performs the following operations to calculate `additionalB` at the end of round 4:
```
// HB refers to Noise handshake hash after the "psk" symbol of round 4 has been processed
if proofA == calculateProof(0, HA):
  proofB = calculateProof(1, HB)
else:
  proofB = RNG(SYM_KEY_LEN)
additionalB = JSON({ proof:proofB }) || zeros(1)
```

The `calculateProof` function is used by both peers:

```
calculateProof(index, hash):
  // LocalHostHasRootKey true <=> the peer executing this function possesses the RootKey
  if(LocalHostHasRootKey == false):
    return RNG(SYM_KEY_LEN)
  return deriveSubkey(parentKey=RootKey, name="handshake-proof", salt=index(1) || hash)
```

The `proofA` and `proofB` fields to to allow the peers to supply proof that they possess knowledge of the passphrase root key. These proofs are calculated so that the verifier must also possess knowledge of the passphrase root key to determine if they are legitimate, and are bound by way of the handshake hash to the specific connection to prevent replay attacks.

The purpose of this is to allow support for higher-level protocol messages that require each peer to have demonstrated read access to the filesystem contents.

Either peer may conceal the fact that it possesses the `RootKey` by sending random bytes in place of a proof. If both peers possess the `RootKey` and the requestor admits to this by sending a valid proof, the responder may choose whether to also admit knowledge by sending its own proof, or to conceal its knowledge by sending a random proof. Peers will not grant access to privileged messages without a valid proof, and so this will limit the responder's behavior in the connection to the requestor to those actions that would be acceptable for a seed-only peer.


### Messaging
The plaintext structure of the messages exchanged by peers is beyond the scope of this document. A given plaintext message is encrypted using the CipherState objects produced per the Noise specification. This includes authenticated encryption proving message integrity.

Messages are transmitted as follows:

| Serialized message |
|-|
| Obfuscated Length (16-bit) |
| Ciphertext |

#### Ciphertext length obfuscation

The `FastHash` function is used to obfuscate the contents of length fields. This is done to prevent a casual observer from distinguishing a sample of EasySafe network traffic from random data. This obfuscation works as follows:

```
Length // Ciphertext length, in bytes
sentByInitiator // True if message is to be sent from initiator to responder; false otherwise

if sentByInitiator:
  out = LenIvA = FastHash(LenKeyA, LenIvA)
else:
  out = LenIvB = FastHash(LenKeyB, LenIvB)
  
ObfuscatedLength = lenBytes ^ (out[0] << 8 | out[1]) // only use first 16 bits of output for XORing length field
```

#### Ciphertext

```
EncryptWithAd // Encryption function from appropriate CipherState, per Noise section 5.1
Plaintext // plaintext payload of message

ciphertext = EncryptWithAd(zeros(0), Plaintext) // Noise section 5.1, using appropriate CipherState from handshake
Length = |ciphertext|(16) // used for ciphertext length obfuscation above
```

#### Rekeying
The `REKEY()` function defined by Noise (see sections 4.2, 5.1, 11.3 of Noise specification) is called after every call to `EncryptWithAd`.

# Discussion

## Argon2 parameter selection

The Argon2d variant is selected for its superior resistance to GPU and ASIC attacks. The alternatives, Argon2i and Argon2id, offer better resistance to side channel attacks. EasySafe is primarily concerned with an adversary that comes into possession of encrypted data and is able to perform offline attacks to decrypt it.

Argon2 offers a tradeoff between time and resource consumption in the form of its parallelism setting. By allowing a high degree of parallelism, a system with many cores can quickly derive a passphrase key, but must invest multiple cores to do so. There is no requirement that these threads actually run in parallel, and a single-CPU system may still perform the derivation.

As a design goal, the remaining Argon2 parameters were chosen so that a system in the 5th percentile of computing power for home users would be able to derive a passphrase key in one minute. As a further design parameter, it is assumed that such a system is likely at 75% utilization due to processes other than EasySafe. This is based on the observation that low-end systems often have high baseline utilization due to the demands of newer operating systems and software, and accumulated background processes.

### Proxy system
A replicable system was defined to act as a proxy to the hypothetical 5th percentile computer running at 75% load. An appropriate number of iterations was then calculated through experimentation on this replicable system.

According to the Steam Hardware and Software Survey of November 2018, over 95% of systems were reported as having at least 4GB of RAM and 2 CPUs.

As the system is assumed to be under 75% load, the Argon2 memory requirement is chosen to be 1GiB based on these figures. The parallelism is set to 16, as an intuitive balance between the number of CPU cores in a typical home computer, and the number likely to be seen in the near future.

The Amazon EC2 t3.small instance was chosen as a suitable proxy system. As a commercial virtual machine, it is highly standardized and easily available as of this writing. The system has 2vCPU and 2GiB RAM, approximating the estimated specifications of the 5th percentile computer.

### Experiment
The proxy system instance was created with a fresh installation of Ubuntu 18.04[1] in the us-east-1d availability zone. The T3 Unlimited option was enabled. The system reported its CPU type in `/proc/cpuinfo` to be `Intel(R) Xeon(R) Platinum 8175M CPU @ 2.50GHz`. The `build-essential` package was installed, and Argon2 was then downloaded, compiled[2] and run from its reference implementation[3], and executed with 16 threads of parallelism and 1GiB of RAM utilization. The salt and passphrase were chosen to be representative of what is expected for ordinary use of EasySafe.

This was repeated at various iteration counts until a count that consistently completed in an average of approximately 15 seconds was identified. The target time of 15 seconds was chosen under the assumption that it is a useful proxy for a target time of 60 seconds on a system under 75% CPU load.

The following command, specifying 40 iterations, was found to have an average completion time of 14.967 seconds[4], with a standard deviation of 82.37ms (n=100):

```
echo -n "landmark maggot errant ranking renewal going" | \
    time -f "%e" ./argon2 easysafe-argon2-salt -d -k 1048576 -p 16 -l 32 -e -v 13 -t 40 > /dev/null
```

Thus, an iteration count of 40 was selected for the Argon2 parameters of EasySafe.

\[1]: Ubuntu 18.04 was installed from the `ami-0ac019f4fcb7cb7e6` image.
\[2]: The gcc 7.3.0-27ubuntu1~18.04 x86_64-linux-gnu compiler was used with Ubuntu GLIBC 2.27-3ubuntu1
\[3]: Obtained from https://github.com/P-H-C/phc-winner-argon2. Commit 6c8653c was used, as it was the latest commit to the 'master' branch at the time of evaluation.
\[4]: When replicating the experiment, the first Argon2 run on a fresh VM was observed to be above 16 seconds. The first run is excluded from the average as an outlier skewed by the need to initialize caches.


### Cost analysis
To assess the security of passphrase keys against brute force attacks, we will consider the question of how long it will take for such an attack to become economically feasible to a highly capable adversary.

#### Real-world performance on high-end system
The attacker's capabilities are chosen to significantly exceed what is likely available to any present-day party. The following Amazon EC2 instance was selected as a benchmark for off-the-shelf computing power as of January 2019:

| | |
|-|-|
| Instance type | c5.18xlarge |
| vCPU | 72 |
| RAM (GiB) | 281 |
| Price | $1.1/hr [1] |

The instance was able to perform most efficiently when 9 simultaneous Argon2 processes were executed. This led to an average rate of 1.275 seconds per derivation, with a standard deviation of 42.008 milliseconds (n=900). This is equivalent to a throughput of 0.7843 passphrase key derivations per second at a price of $1.1/hr, or 2.566 kHash/$.

[1]: This is based on the lowest observed "spot rate" for the instance, reflecting the market price for unused capacity. This price is roughly equivalent to Amazon's least-expensive published means purchase this instance on a long-term basis, which is $1.104/hr. for a prepaid 3-year contract.

#### Adversary model

For the purposes of this model the following assumptions are made:

1. The adversary has a finite budget for computing key derivations.
2. The adversary can instantly compute passphrase key derivations at a rate of 26 kHash/$.
3. The cost decreases exponentially at a rate of 50% per 18 months.

We will now suppose several different passphrase classes. Each class is listed with the amount of money the adversary described in this section must spend as of 2019 to have a 50% chance of brute forcing a passphrase from that class. An adversary is guaranteed to find the passphrase with a budget of double the average cost.

| Entropy (bits) | Description                                          | Example                              | 2019 average cost
|--------|--------------------------------------------------------------|----------------------------------------------|---
| 13.280 | Random selection from 10,000 most commonly-used passwords    | letmein                                      | $0.1913
| 19.930 | Random selection from 1,000,000 most commonly-used passwords | Nokia6233                                    | $19.21
| 51.700 | 4 random words, 12.925 bits entropy/word (Diceware model)    | correct horse battery staple                 | $70.35 billion
| 64.625 | 5 random words                                               | semantic defender unfold another penalize    | $547.1 trillion
| 77.550 | 6 random words                                               | landmark maggot errant ranking renewal going | $4.255 quintillion
| 256    | Derived key size                                             | L*YVS4}@u%i$/X%\_%^NW&hDsOXx=W{n0#.UI8.y     | $2.227 x 10^72

The 256 bit level represents an upper bound on the complexity of an adversary's attack. For some passphrase strength <= 256 bits, it becomes more economical for the adversary to attack the derived keys directly, bypassing the key derivation algorithm entirely.

The following analysis calculates the year in which an adversary will have a 50% chance of discovering the passphrase via brute force within a fixed budget in US dollars, as valued in 2019. It is expected in this model that inflation will affect the attacker's budget and cost of computing equally.

The largest listed budget is $100 trillion, roughly equivalent to the present global GDP. This is chosen as an upper bound on the budget of any adversary. The minimum budget is $0.001. This is chosen as a point where the cost of brute forcing the passphrase is truly negligible, and the adversary may become indifferent as to whether the filesystem had been unencrypted in the first place. This threshold is not easy to define objectively, and it is also unclear when storage costs will make a rainbow table economical for each passphrase class.

| Entropy (bits) | $0.001 | $1   | $1,000 | $1 million | $1 billion | $100 trillion
|----------------|--------|------|--------|------------|------------|---------------
| 13.280         | 2030   | Now  | Now    | Now        | Now        | Now
| 19.930         | 2040   | 2025 | Now    | Now        | Now        | Now
| 51.700         | 2088   | 2073 | 2058   | 2043       | 2028       | Now
| 64.625         | 2107   | 2092 | 2077   | 2062       | 2047       | 2027
| 77.550         | 2126   | 2111 | 2096   | 2081       | 2066       | 2047
| 256            | 2394   | 2379 | 2364   | 2349       | 2334       | 2314

##### Rainbow tables
An attacker has the option of maintaining a "rainbow table" storing the keys derived from every possible passphrase in a class. They could then attempt any of their cached passphrases with a negligible time or computing cost compared to the cost of the key derivation function. An attacker must still conduct an initial brute force attack and store the results, which is impractical for sufficiently-strong passphrases. For weaker passphrases, this option is economical.

If each row of the table had a 256-bit identifier based on the passphrase, and the derived key, then the 2^19.93 level would require 256MiB in storage, and cost the modeled adversary approximately $38.40 to compute.

##### Overestimate of adversary capabilities
The above model is presented to provide an estimate for the minimum duration EasySafe can resist brute force attacks against the passphrase. The model assumes an exponential reduction of cost by 50% every 18 months, which may not be sustainable due to limitations imposed by, among other things, the laws of thermodynamics.

In ideal conditions, a perfectly-efficient computer powered with the total energy output of a typical supernova could count to 2^219.[1] This is several hundred billion times less expensive than counting to 2^256. This does not account for any of the energy needed to perform any calculations with this counter, such as Argon2 key derivations.

The prediction that the adversary will have access to billions of supernovas worth of energy for the present-day value of $0.001 suggests that the model strongly overestimates the adversary's capabilities. Therefore, the actual lifespan of the confidentiality provided by a passphrase is likely to be greater than what is predicted in this section.

[1] Schneier, Bruce. (1996). Applied Cryptography, Second Edition. Page 158.

##### Inadequacy of ordinary passphrases
Weak passphrase selection is an ongoing problem in information security. Even given a key derivation function that is extremely expensive by current standards, the most commonly-used passwords are economical to attack even today. Users must select passphrases much stronger than what is typically selected today for EasySafe to provide a reasonable assurance of confidentiality.

## Threat model

### Basic model
The basic threat model refers to an adversary with strong capabilities, including knowledge of keys used for data-in-transit. Additional threat models will consider additional guarantees that can be made when an adversary possesses fewer capabilities. The basic threat model is intended to consider the security guarantees offered by the file system, disregarding any network-level security.

#### Basic adversary capabilities

The basic adversary is assumed to possess...

1. ...the ability to view, alter, extend, truncate, create and/or drop any packet sent to or from any EasySafe peer.
1. ...the ability to view, alter, extend, truncate, create and/or delete any file directly created by EasySafe on any host filesystem anywhere in realtime.\[1]
2. ...knowledge of the contents of every file directly created by EasySafe on any host filesystem at any point in history.
1. ...knowledge of the filesystem's `SeedKey` and FSID
1. ...knowledge of the version and full source code of any EasySafe application running on any peer
2. ...knowledge of all key material used to encrypt network communications, including static keypairs, ephemeral keypairs, preshared secrets and any keys derived from aforementioned material.\[2]
3. ...knowledge of the identities of each peer
4. ...access to the `InodeTableOracle` function, by which the adversary can at no cost identify inode table pages to attack.
5. ...access to the `SuperPageEncryptionOracle` function, by which the adversary can at no cost craft arbitrary properly-encoded pages with arbitrary plaintext.
6. ...access to the `SuperPageTreeChunkEncryptionOracle` function, by which the adversary can at no cost craft arbitrary properly-encoded page tree chunks with arbitrary plaintext.
5. ...the ability to perform `PBKDF` operations with no cost.

##### Oracle definitions

```
// allow adversary to determine if a given tag belongs to an inode table
InodeTableOracle(tag, contents):
  isInodeTable // set true <=> the file represents the contents of a page of the inode table
  pageNum // set to page number of this inode table page if isInodeTable, else undefined
  refTag // set to the refTag of the inode table this page belongs to if isInodeTable, else undefined
  return [isInodeTable, refTag, pageNum]

// allow adversary to craft an arbitrary encrypted page for a pre-specified distinguisher
SuperPageEncryptionOracle(distinguisher, pageNum, pageText)

// allow adversary to craft an arbitrary page tree chunk
SuperPageTreeChunkEncryptionOracle(distinguisher, chunkNum, chunkText)

// allow adversary to craft an arbitrary encrypted page; distinguisher is randomly selected and not provided to adversary
PageEncryptionOracle(pageNum, pageText)

// allow adversary to craft an arbitrary encrypted page tree chunk; distinguisher is randomly selected and not provided to adversary
PageTreeChunkEncryptionOracle(chunkNum, chunkText)

```

\[1]: This does not extend to virtual memory dumps that may include sensitive key material. Nothing in this threat model should be taken to indicate that EasySafe provides security against an adversary with physical or privileged access to a peer's system while EasySafe is in operation.

\[2]: This does not apply to key material related to the filesystem. Specifically, the basic adversary does not have knowledge of the passphrase, `RootKey`, `FSKey`, or any keys derived from this material.

##### Basic adversary limitations

The adversary's capabilities are limited to those things listed above. The following non-comprehensive list of limitations is provided to minimize confusion.

The adversary does not possess...

1. ...advance knowledge of the read or write passphrase, `WritePrivateKey`, `RootKey` or `FSKey`.
2. ...the ability to read the contents of EasySafe's memory.
3. ...a technique for attacking any of the cryptographic primitives in less average time than a brute force attack.
4. ...information about the filesystem other than what is stated in the definition, written to disk or sent over the network. The adversary has knowledge of the sequence of operations, but not their exact timing.[3]

\[3] In reality, even casual observers almost certainly possess information about timing. Real adversaries may also possess other information such as sound, power utilization or EM radiation, any of which could enable a side channel attack. This restriction is intended to exclude matters of implementation and physical security from the analysis.

#### Basic filesystem assumptions

The following assumptions are made of the structure of the filesystem.

1. The passphrase key contains K bits of entropy, K <= 256.
2. The filesystem has P files containing pages or page tree chunks unrelated to the inode table.
3. Any page within the filesystem possesses a minimum of F bits of entropy.

#### Basic security levels
EasySafe provides the following guarantees against the basic adversary. The adversary faces the following complexities:

TODO: Sketch out algorithm/proof for each attack to show complexity, put online, provide link here.

| Task                                              | Minimum complexity (log 2) | Notes    |
|---------------------------------------------------|--------------------|----------|
| Delete data from a filesystem                  | 0 | The adversary can delete arbitrary pages from all peers, but does not have knowledge of what is being deleted beyond whether it is an inode table without performing a separate and more costly attack.
| Insert data into a filesystem | K | The adversary can craft fake data using the `SuperPageEncryptionOracle` function, but cannot craft a fake RevisionTag.
| Determine authorship of encrypted page            | 0 | Adversary has capability to observe first peer to transmit page
| Determine the contents of a page in the filesystem | (64 + F)\[1]      | Adversary brute forces guesses of file contents and `inodeIdentity` through `SuperPageEncryptionOracle`
| Determine the number of files in the filesystem | 0\[2] | Adversary can learn approximate number based on inode table size, learned through `InodeTableOracle`. |
| Determine when a file is unlinked from the filesystem | (64 + F)\[1,3,4] | Best known option is brute force of root directory, assuming file is in root directory (worst case)
| Determine the specific size of a file in the filesystem | K[3] | Other than traffic analysis[3], best known option is brute force attack on inode table
| Determine names of files within filesystems | (64 + F)\[1,4] | Brute force of root directory
| Determine `stat_t`-like metadata concerning a file in the filesystem | K | Best known option is brute force attack on inode table
| Determine whether a given file is in the filesystem | (64 + P)\[1] | Adversary combines `SuperPageEncryptionOracle` with a brute-force attack on 64-bit inodeIdentity against the IVs of each page observed in the filesystem


\[1]: or K, if K is lesser.
\[2]: Adversary learns approximate number, and not exact figure.
\[3]: The adversary may be able to infer this information by observing how often certain pages are downloaded. These patterns vary depending on use case.

### Restricted model
The restricted threat model refers to an adversary whose capabilities are more limited compared to the basic model, with the following capability differences:

#### Restricted adversary capabilities

The restricted adversary possesses...

1. ...the ability to view, alter, extend, truncate, create and/or drop any packet sent to or from any EasySafe peer.
1. ...a copy of all data written to the EasySafe filesystem in encrypted form.
1. ...knowledge of the filesystem's `SeedKey` and FSID
1. ...knowledge of the version and full source code of any EasySafe application running on any peer
4. ...access to the `InodeTableOracle` function, by which the adversary can at no cost identify inode table pages to attack.
5. ...access to the `PageEncryptionOracle` function, by which the adversary can at no cost craft arbitrary properly-encoded pages with arbitrary plaintext.
6. ...access to the `PageTreeChunkEncryptionOracle` function, by which the adversary can at no cost craft arbitrary properly-encoded page tree chunks with arbitrary plaintext.
5. ...the ability to perform `PBKDF` operations with no cost.

#### Restricted adversary limitations

The restricted adversary has the same limitations as the basic adversary.

#### Restricted model security levels

TODO: Sketch out algorithm/proof for each attack to show complexity.

| Task                                              | Complexity (log 2) | Notes    |
|---------------------------------------------------|--------------------|----------|
| Delete data from a filesystem                  | N/A | The adversary cannot delete data from peer storage, and all existing files are immutable by design.
| Insert data into a filesystem | K | The adversary can craft fake data using the `PageEncryptionOracle` function, but cannot craft a fake RevisionTag.
| Determine authorship of encrypted page[3]            | N/A | 
| Determine the contents of a page in the filesystem | K      | 
| Determine the number of files in the filesystem | 0 | Adversary can learn approximate number based on inode table size, learned through `InodeTableOracle`.
| Determine when a file is unlinked from the filesystem | K | 
| Determine the approximate size of a file in the filesystem | K[3] | Other than traffic analysis[3], best known option is brute force attack on inode table
| Determine names of files within filesystems | K | 
| Determine `stat_t`-like metadata concerning a file in the filesystem | K | Best known option is brute force attack on inode table
| Determine whether a given file is in the filesystem | K | 


\[1]: or K, if K is lesser.
\[2]: Adversary learns approximate number, and not exact figure.
\[3]: The adversary may be able to infer this information by acting as a seed and noting patterns in the upload and download of pages. These patterns vary depending on use case, and the adversary must be online as a seed to perform this method.

## Rationales

### Why not use JSON for the config file?
Using JSON would mean that FSIDs would not follow deterministically from passphrases for default filesystems, since JSON does not guarantee a unique serialization for a given object.

### Why was the c5.18xlarge chosen in the Argon2 model?
Several other instance classes, including the z1d.12xlarge were considered. In general, high-end instances had similar levels of performance once the number of vCPUs were taken into account, and the c5.18xlarge had the best performance per dollar of anything tested. Taking this instance at its lowest available price seems to be likely to get at least a rough picture of what an adversary can do today with easily-available resources.

The adversary in the model is presumed to perform 10x more cost-effectively than the c5.18xlarge instance, to ensure that the adversary's capabilities are overestimated even if there is a more efficient option available today.

### Why encode the filesystem config tag and page length in the FSID?
Peers receiving a filesystem for the first time need certain bootstrap info. The swarm protocol relies on parties agreeing on page size in advance. Although this is in the filesystem config, the filesystem config itself must be transmitted through the protocol. By encoding the page size directly into the ID, naive peers can immediately join in the swarm. By also basing the ID on the config tag, the configuration file can be validated to prove that it corresponds to the intended FSID.

### Why use the "symobf" option instead of something like Elligator2?
As of this writing, Elligator2 support is difficult to find. The symobf technique is similar to the methodology used in the i2p project's NTCP2 protocol.

### Why not use ephemeral keys for the DHT protocol?
The DHT protocol is stateless, and also very size constrained. At present, DHT messages are limited to a maximum size of 508 bytes. Using an ephemeral key would consume additional space in the packet, and require a significant increase in the CPU load created by the protocol due to the extra Diffie-Hellman operation.

### What is the purpose of encrypting RevisionTags?
Seed peers must be able to receive RevisionTags so they can be relayed to read-access peers. If the revision tags were not encrypted, the seed peers would gain unnecessary insight into the structure of the filesystem.

### Why does taggedEncrypt do encrypt-then-MAC instead of an AEAD cipher?
The resulting tag would not be verifiable by seed peers, who do not possess the symmetric key used to produce the ciphertext. The MAC is calculated using a key derived from the seed root. Using an AEAD cipher in addition to this MAC would be an additional CPU cost, when authenticity and integrity are already guaranteed.

### Why does taggedEncrypt use both an encrypt-then-MAC hash and an asymmetric signature?
A peer processing an incoming page or chunk must be able to provde three things, using knowledge of the seed key and public write key:

1. The text has not been tampered with.
2. The text was created by someone with knowledge of the private write key.
3. The text belongs to this filesystem, and not another filesystem that the write key may have been used for.

The asymmetric signature proves both 1) and 2), whereas the authenticated hash proves 1) and 3). Furthermore, the authenticated hash can be validated much more quickly, offering a reduced-cost way to perform integrity checking over a large batch of data.

### Why not support de-duplication?
The use of page- and inode-specific derived keys with random salts provides resistance against the chosen plaintext capabilities granted in the threat models (e.g. `PageEncryptionOracle`).

Later versions may support page-independent keys with deterministic IVs as an option for users who desire de-duplication.

### What if I want to revoke someone's access to a filesystem, or change the passphrase?
Filesystem passphrases are immutable. One option is to migrate the data in the filesystem to one with a new passphrase. This passphrase would then need to be distributed to the authorized parties. The means for doing this are beyond the scope of this document.

### Why are side channel attacks excluded from the models?
Side channel attacks are very difficult to model. Although design decisions can make a system more or less resistant to some side channel attacks, no design can possibly foil all of them. Major classes of security issues come down to hardware, implementation and physical security concerns.

Certain real-world adversaries possess capabilities that go beyond the security model here and can easily break it. For instance, EasySafe has no means of protecting you if you are imprisoned and tortured until you reveal your passphrase. EasySafe cannot protect you from adversaries that participate in the thriving clandestine market for undisclosed exploits that will allow them access to your system. It also can't protect you if your adversary has access to a secret backdoor built into your CPU by the manufacturer.
