# EasySafe Cryptography Overview

###### Author

Jonas Acres
jonas@acrescrypto.com

###### Version
Revision PRE-01, 2019-01-01

###### Intellectual Property

(blah blah creative commons thing goes here ultimately. for now, PLEASE DO NOT REDISTRIBUTE!)

The author is not aware of any patents encumbering the methods described in this document.

## Purpose

This document explains the cryptography used in EasySafe.

EasySafe is a virtual distributed filesystem. Filesystem data is encrypted at rest, and peers locate one another and share information through a decentralized system with no locus of control. Knowledge of a passphrase is necessary and sufficient to identify an archive, locate a peer swarm, read and write to the filesystem in the default configuration.

## Conventions

### Terminology

* **Archive:** A filesystem identified by a passphrase.

### Concatenation operator

The `||` operator denotes concatenation. Example:

`"abc" || "def"   // "abcdef"`

When the `||` operator is applied to an integer, the integer is to be serialized in big-endian byte order. The size of the integer field in bits is explicitly specified in all cases. For example:

```
x = 1234
y = "abc" || x(32)   // y = { 'a', 'b', 'c', 0x00, 0x00, 0x12, 0x34 }
```

### Size operator

The operation `|x|` on a byte string `x` returns the number of bytes in `x`. Example:

```
x = "abc"    // |x| = 3
```

### Standard crypto functions

A number of cryptographic primitives are used here. The name by which they appear in this document, as well as the specific algorithms chosen, are listed here.

| Name | Algorithm | Length (bits) |
|------|--------------------|--------------|
| Hash(data) | Blake2b            | 512         
| FastHash(key, data) | SipHash-2-4 | 64
| HMAC(key, data)| RFC 2104           | 
| HKDF(key, data) | RFC 5869     | 
| SymmetricEncrypt(key, iv, plaintext) | ChaCha20 | 256 key / 96 nonce
| SymmetricEncryptAEAD(key, iv, plaintext) | ChaCha20-Poly1305 | 256 key / 96 nonce / 128 tag
| AsymmetricSharedSecret(privateKey, publicKey) | X25519 | 256
| AsymmetricSign(privateKey, data) | Ed25519 | 256
| AsymmetricVerify(publicKey, signature, data) | Ed25519 | 256
| PBKDF(passphrase) | Argon2\[1] | 256

\[1] See additional Argon2 settings.

#### Argon2 settings

| Argon2 Setting | Value                  |
|----------------|------------------------|
| mode           | Argon2d                |
| salt           | "easysafe-argon2-salt" |
| parallelism    | 16 threads             |
| tagLength      | 256 bits               |
| memorySize     | 1 GiB                  |
| iterations     | 40                     |

## Basic constants
| Constant name    | Value | Unit | Description
|------------------|-------|------|
| HASH_LEN         | 64              | bytes | Output length of Hash() function
| SYM_KEY_LEN      | 32              | bytes | Symmetric key size
| SYM_IV_LEN       | 16              | bytes | Symmetric initialization vector size in unauthenticated mode (equivalent to block size)
| SYM_AEAD_IV_LEN  | 16              | bytes | Symmetric initialization vector size in authenticated mode
| SYM_AEAD_TAG_LEN | 16              | bytes | Tag size for symmetric encryption in authenticated mode
| ASYM_SIG_LEN     | 64              | bytes | Output length of AsymmetricSign() function
| PAGE_SIZE        | 65536 (default) | bytes | Configurable fixed page size for archive.


## Non-standard functions

Certain non-primitive or non-standard operations are performed throughout this document. They are defined here.

```
ASSERT(booleanValue)
  // Abort processing if booleanValue is not true.
```

```
RandomBytes(length)
  // return 'length' randomly generated bytes from a CSPRNG or TRNG
```

```
zero(n): // return n bytes all set to 0
  return { 0x00, 0x00, ..., 0x00 } // n bytes total

example:
  zero(4) = { 0x00, 0x00, 0x00, 0x00 }
```

```
int(data) // deserialize bytes as big-endian integer

example:
  int({0x00, 0x00, 0x12, 0x34}) // 0x1234
```

```
pad(data, size):
  return |data|(32) || data || zero(size - |data|)
```

```
unpad(data):
  len = int(data[0 ... 4])
  return data[4 ... 4 + len]
```

```
deriveSubkey(parentKey, type, index, tweak):
  return HKDF(ikm=parentKey, length=SYM_KEY_LEN, salt=tweak || type(16) || index(16), info="zksync-subkey");
```

```
taggedEncrypt(symRootKey, authKey, signPrivateKey, plaintext):
  salt = HKDF(ikm=plaintext, length=16, salt=symRootKey, info="easysafe-tagged-file-salt")
  derivedKey[SYM_KEY_LEN] = HKDF(ikm=salt, length=SYM_KEY_LEN, salt=symRootKey, info="easysafe-tagged-file-key")
  paddedPlaintext = pad(data=plaintext, len=PAGE_LEN) // must have: |plaintext| <= PAGE_LEN
  ciphertext = SymmetricEncrypt(key=derivedKey, iv=zeros(SYM_IV_LEN), plaintext=paddedPlaintext)
  
  signature = AsymmetricSign(privateKey=signPrivateKey, data=salt || ciphertext)
  output = salt || ciphertext || signature
  tag = HMAC(key=authKey, data=output)
  
  return tag, output
```

```
taggedDecrypt(symRootKey, authKey, signPrivateKey, tag, signedCiphertext):
  salt = HKDF(ikm=plaintext, length=16, salt=symRootKey, info="easysafe-tagged-file-salt")
  derivedKey[SYM_KEY_LEN] = HKDF(ikm=salt, length=SYM_KEY_LEN, salt=symRootKey, info="easysafe-tagged-file-key")
  ciphertext = signedCiphertext[16 ... |signedCiphertext| - ASYM_SIG_LEN]
  signature = signedCiphertext[|signedCiphertext| - ASYM_SIG_LEN ... |signedCiphertext|]
  
  ASSERT(HMAC(key=authKey, data=signedCiphertext) == tag)
  ASSERT(AsymmetricVerify(publicKey=signPrivateKey, signature=signature, data=salt || ciphertext))
  
  paddedPlaintext = SymmetricDecryptStream(key=derivedKey, iv=zeros(SYM_IV_LEN), ciphertext=ciphertext)
  return unpad(paddedPlaintext)
```

# Archive definition
An EasySafe filesystem is referred to as an "archive." The structure of an archive is described in this section. Details for constructing elements of the archive are described in the remainder of this document.

## Configuration
Each archive has a configuration, containing the following data:

| Field name | Size (bytes) | Description | Default value
|------------|-------------|-------------|----------|
| PageSize   | 8           | Fixed length of config, page and page tree chunk files | 65536
| Description | Variable   | User-specified string providing immutable description of archive | zero(0)
| ArchiveRoot | `SYM_KEY_LEN`         | Symmetric key used to derive all other symmetric keys for content encryption | PassphraseRoot
| WritePubKey | `ASYM_PUBKEY_LEN` | Asymmetric public key used to verify authenticity of archive content | See section XXX TODO

A "default archive" is one in which all fields contain their default values. Thus, a default archive's configuration can be deterministically generated from its passphrase root.

## Configuration file
An archive's configuration data is written in an archive config file. This file is structured as follows:

```
Config file diagram

+ Config (PageSize)
    | version hash       (16)
    | salt               (32)
    + seed fixed         (4)
      | seed_len           (4)
    + seed variable      (6 + variable...)
      | recordCount        (2)
      + records            (4 + variable...)
        | flags              (2)
        | version            (1)
        | nameLen            (1)
        | name               (variable)
        | payloadLen         (2)
        | payload            (variable...)
    + secure fixed       (4)
      | secure_len         (4)
    + secure variable    (6 + variable...)
      | recordCount        (2)
      + records            (4 + variable...)
        | flags              (2)
        | version            (1)
        | nameLen            (1)
        | name               (variable...)
        | payloadLen         (2)
        | payload            (variable...)
    | padding...         (fill empty space to PageSize)
    | signature          (ASYM_SIG_SIZE)

flags:
  0x01 MANDATORY: if set, and client does not support record type, then client MUST refuse to process archive or participate in swarm.

records:
  secure-config:
    archive root
    description
  seed-config:
    write public key
  expiration:
    deadline (once elapsed, client must stop sharing)
    destroy (if set, client must also delete data)
  killphrase:
    hash (when revtag preimage to hash received, client must stop sharing)
    destroy (if set, client must also delete data)
    relay (if set, client should remain on swarm, only announcing killphrase revtag for state period of time after receipt)
```



```
seedAuthKey = deriveSubkey(root=SeedKey, type=AUTH, name="easysafe-config-seed-auth")

version = HKDF(ikm=zeros(2), len=16, salt=seedAuthKey, info="easysafe-version")

securePayload = ArchiveRoot || |Description|(16) || Description
securePlaintext = 1(16) || 0(16) || 0(8) || 13(8) || "secure-config" || |securePayload|(16) || securePayload

seedPayload = WritePubKey || PageSize(64)
securePlaintext = 1(16) || 0(16) || 0(8) || 11(8) || "seed-config" || |seedPayload|(16) || seedPayload

saltMaterial = |seedPlaintext|(16) || seedPlaintext || |securePlaintext|(16) || securePlaintext
secureSalt = HKDF(ikm=saltMaterial,
  length=32,
  salt=secureRootKey,
  info="easysafe-config-secure-salt")

seedTextTweak = hash(version || secureSalt)
seedTextKey = deriveSubkey(root=SeedKey,
  type=CIPHER,
  name="easysafe-config-seed-text:" || secureTextTweak)
seedCiphertext = SymmetricEncrypt(key=seedTextKey,
  iv=nonce(1),
  data=seedPlaintext)
seedFixed = SymmetricEncrypt(key=seedTextKey,
  iv=nonce(0),
  data=|seedCiphertext|(32)

secureTextTweak = hash(version || secureSalt || seedFixed || seedCiphertext)
secureTextKey = deriveSubkey(root=PassphraseKey,
  type=CIPHER,
  name="easysafe-config-secure-text:" || secureTextTweak)
secureCiphertext = SymmetricEncrypt(key=secureTextKey,
  iv=nonce(1),
  data=securePlaintext)
secureFixed = SymmetricEncrypt(key=secureTextKey,
  iv=nonce(0),
  data=|secureCiphertext|(32))

unpadded = version || secureSalt || seedFixed || seedCiphertext || secureFixed || secureCiphertext
padKey = deriveSubkey(root=PassphraseRoot,
  type=AUTH,
  name="easysafe-config-padding")
padding = HKDF(ikm=padKey,
  length=PageSize - |unpadded| - ASYM_SIG_LEN,
  salt=unpadded,
  info="easysafe-config-padding")

unsigned = unpadded || padding
signature = AsymmetricSign(key=WritePrivKey, data=unsigned)

configFileBytes = unsigned || signature

prefix = HKDF(ikm=configFileBytes, length=HASH_LEN-16-SYM_TAG_LEN, salt=SeedRoot, info="easysafe-config-id-tag")
data = "easysafe" || PageSize(64)
dataKey = deriveSubkey(root=SeedRoot, type=CIPHER, name="easysafe-config-id-data:" || prefix)
pageSizeCiphertext = SymmetricEncryptAEAD(key=dataKey, iv=zeros(SYM_IV_LEN), plaintext=data)

archiveId = prefix || pageSizeCiphertext

tag = HMAC(key=seedAuthKey, data=archiveId)

// Content of configFile = configFileBytes
// tag is used as filename
```

## File storage

### Inode table
Every file in an archive is indexed within an inode. The inode contains basic information beyond the scope of this document, similar to that described in a POSIX `stat_t` structure. Additionally, the inode contains a 64-bit randomly-generated `inodeIdentity` field which is constant for the life of the file, and a RefTag.

### RefTags

A RefTag is an identifier allowing retrieval of a file from an archive. It is structured as follows:

| Field | Size | Description
|-------|--------|----|
| tag   | HASH_LEN | Context-dependent on refType
| numPages | 8 | Number of pages in file. Does not include page tree chunks.
| refType | 1 | Reference type, determines meaning of `tag` field. See below for acceptable values.
| reserved | 3 | Reserved for future use.

The `refType` field takes on values from the following table:

| Value | Symbol | tag field semantics | Used when...
|-------|--------|---------------------|----|
| 0     | REF_TYPE_IMMEDIATE | Tag field contains literal file contents, zero-padded to HASH_LEN | File size < HASH_LEN
| 1     | REF_TYPE_INDIRECT | Tag field contains tag of only page in file. | HashLen <= File size <= PageSize
| 2     | REF_TYPE_2INDIRECT | Tag field contains tag of root page tree chunk. | File size > PageSize

The "Page" and "Page Tree" structures are described below.

### Pages
Files are divded into individual pages of fixed length for storage. The plaintext content of each page has length `PageSize + 4`, and is padded as needed to reach this amount. The plaintext of each page is calculated as follows:

```
getPageText(filePlaintext, pageNum):
  endOffset = Min((pageNum+1)*PageLen, |filePlaintext|)
  return pad(filePlaintext[pageNum*PageLen ... endOffset], PageLen)
```

Pages are encrypted and stored to disk:

```
// inodeIdentity from file's inode entry
// pageText from getPageText
storePage(inodeIdentity, pageNum, pageText):
  tweak = inodeIdentity(64) || pageNum(64)
  pageSymKey = deriveSubkey(rootKey=ArchiveRoot, type=CIPHER, name="page:" || tweak)
  pageAuthKey = deriveSubkey(rootKey=SeedRoot, type=AUTH, name="page:" || tweak)
  tag, ciphertext = taggedEncrypt(symKey=pageSymKey, authKey=symAuthKey, signPrivateKey=WritePrivateKey, plaintext=pageText)
  writeTaggedFile(tag, ciphertext)
  return tag
```

If a file consists of exactly one page, then the resulting tag of that page is used to create the RefTag stored in the file's inode, with type `REF_TYPE_INDIRECT`.

### Page trees
Individual pages can only be read if their page tag is known. When a file consists of only a single tag, the tag is stored directly in the inode table for the file. For files containing multiple tags, the tags are stored in a B-tree structure known as a "page tree". Each node of the page tree is known as a "page tree chunk." Leaf page tree chunk contains a list of page tags. Branch page tree chunks contain the tags of child page tree chunks.

Page tree chunks are encrypted and stored as follows:

```
// inodeIdentity from file's inode entry
// chunkNum is index of chunk within tree
// chunkText = (tag0 || tag1 || ... || tagN), serialization of all tags in chunk
storeChunk(inodeIdentity, chunkNum, chunkText):
  tweak = inodeIdentity(64) || chunkNum(64)
  chunkSymKey = deriveSubkey(rootKey=ArchiveRoot, type=CIPHER, name="chunk:" || tweak)
  chunkAuthKey = deriveSubkey(rootKey=SeedRoot, type=AUTH, name="chunk:" || tweak)
  tag, ciphertext = taggedEncrypt(symKey=chunkSymKey, authKey=chunkAuthKey, signPrivateKey=WritePrivateKey, plaintext=chunkText)
  writeTaggedFile(tag, ciphertext)
  return tag
```

The tag of the root chunk (`chunkNum` == 0) is used to create the RefTag stored in the file's inode, with type `REF_TYPE_2INDIRECT`.

### Inode table serialization

The inode table itself is serialized as a file, using the same paging methodology described above. The `inodeIdentity` of the inode table is always set to 0. Because the inode table cannot store its own RefTag, the resulting RefTag (regardless of its refType) is used to create a RevisionTag.

### RevisionTags

A RevisionTag provides an entry point into the filesystem, similar to a git commit hash.

```
// parentRevisionTag is revision tag of previous version of inode table, or zeros if this is the first revision
// height is 1 + (height of the previous revision), or 0 if this is the first revision
createRevisionTag(refTag, parentRevisionTag, height):
  plaintext = refTag || parentRevisionTag[0 ... 8] || height(64)
  obfuscator = HKDF(ikm=plaintext, length=16, salt=ArchiveRoot, info="revision-tag-obfuscator")
  revTagKey = HKDF(ikm=obfuscator, length=SYM_KEY_LEN, salt=ArchiveRoot, info="revision-tag-key")
  
  ciphertext = SymmetricEncrypt(key=revTagKey, iv=zeros(SYM_IV_LEN), data=plaintext)
  obfuscated = obfuscator || ciphertext
  signature = AsymmetricSign(key=writeKey, data=obfuscated)

  return obfuscated || signature
```

An obfuscator is derived deterministically from the plaintext to ensure that a given RefTag always produces the same RevisionTag. The obfuscator is again combined with the archive root via HKDF to ensure that only peers possessing knowledge of the archive root can decipher the RefTag. A signature is applied to allow seed-only peers to verify that a given RevisionTag is authorized by a party with knowledge of the write key prior to relaying the RevisionTag to other peers.

There is a tradeoff between the length of the obfuscator (and therefore efficiency of representation), and the probability of two RevisionTags producing identical obfuscators. With a 128-bit obfuscator, this happens on average once per 2^64 RevisionTags. The confidentiality of these RevisionTags will then be lost. The presumption that an adversary is able to do this for all revisions is modeled as the InodeTableOracle in the basic threat model.

## Distributed Hash Table

EasySafe allows archive peers to discover one another by means of a distributed hash table (DHT). This DHT allows peers with knowledge of an archive ID and seed key to discover "advertisements" listing connection information for other peers possessing the same information.

### DHT protocol
The particulars of the DHT protocol are provided in a separate document, entitled "EasySafe Network Specification." Discussion in the present document is limited to the cryptographic aspects of this protocol. The function of the DHT is summarized by the following functions:

| Function | Result | Description
|----------|--------|-------------
| DHTLookup(temporalSeedId) | Zero or more Advertisements | Locate Advertisements for connectable peers sharing a given seed ID
| DHTSet(peer, temporalSeedId, ad) | None | Request a remote peer to store an advertisement for a given seed ID

### Message-level cryptography
Each DHT peer has a static X25519 keypair used to encrypt messages. Message plaintexts are encrypted using key material derived from the shared secret produced by the static keys of the two parties. Because these keys are static, a compromise of a peer's private key allows an adversary retroactive decryption of any previous messages sent during the lifespan of that key.

Messages are encrypted and serialized as follows:
```
// NetworkID is a fixed constant, specific to the DHT
// 'plaintext' is the raw plaintext of a DHT protocol message
// remotePubKey is the X25519 static public key of the receiving peer
// localPubKey is the X25519 static public key of the local peer
// localPrivKey is the X25519 static private key of the local peer

randomBytes = RNG(16)
obfKey = HKDF(ikm=remotePubKey, length=SYM_KEY_LEN, salt=NetworkID || randomBytes, info="easysafe-dht-obfkey")

obfuscatedPubKey = SymmetricEncrypt(key=obfKey, iv=zeros(SYM_IV_LEN), plaintext=localPubKey)
salt = networkId || randomBytes || obfuscatedPubKey
dhSecret = DH(localPrivKey, remotePubKey)

messageKey = HKDF(ikm=dhSecret, length=SYM_KEY_LEN, salt=salt, info="easysafe-dht-msgkey")
ciphertext = SymmetricEncryptAEAD(key=messageKey, iv=zeros(SYM_IV_LEN), plaintext=plaintext)

serialized = randomBytes || obfuscatedPubKey || ciphertext
// 'serialized' is transmitted to remote peer
```

### Temporal seed IDs
The temporal seed ID is a time-dependent derivative of the seed root key, which is in turn derived from an archive's passphrase.

```
// EpochSeconds = # seconds elapsed since 1970-01-01 00:00:00 UTC
timeslice = floor(EpochSeconds / (60*60*3))
temporalSeedId = deriveSubkey(rootKey=SeedKey, type=AUTH, name="temporal-seed-key:" || timeslice(64))
```

#### Lookup tokens
When performing the `DHTLookup` operation, each individual request contains a lookup token. This token is constructed as follows:

```
// peerPublicKey is static X25519 key of remote peer
lookupKey = deriveSubkey(rootKey=SeedRoot, type=AUTH, name="dht-lookup")
lookupToken = HMAC(key=lookupKey, temporalSeedId || peerPublicKey)
```

The same `lookupToken` is provided in requests made during the `DHTSet` operation. `DHTLookup` requests with advertisements that were listed with the same `lookupToken`.

### Advertisement content
Advertisements contain plaintext routing information, including IP address and TCP port number. Advertisements also contain an encrypted archive ID field, calculated as follows:

```
// peerPublicKey is static X25519 key of remote peer
rng = RNG(SYM_IV_LEN)
key = deriveKey(rootKey=SeedKey, type=CIPHER, name="dht-ad:" || lookupToken || rng)
encryptedArchiveId = SymmetricEncryptAEAD(key=key, iv=zeros(SYM_IV_LEN), plaintext=ArchiveId)

// rng and encryptedArchiveId included in ad
```

## Swarming
EasySafe peers participate in a peer-to-peer swarm to share archive data.

### Swarming protocol
As with the DHT protocol, the particulars of the swarming protocol are not considered in this document, beyond what is needed to exmaine its cryptographic aspects.

### Handshaking

Handshaking and message encryption follow the standards of the Noise specification, as of Revision 34.[TODO cite] The protocol name is `Noise_XKpsk4+symobf_25519_ChaChaPoly_BLAKE2b`.

In Noise notation, the handshake pattern is expressed as follows:
```
// PSK is archive ID
// Server static key learned by client from DHT or other mechanism
// | denotes message payload, which is to be encrypted per Noise specification
XKpsk4:
  <- s
   ...
  -> e, es
  <- e, ee
  -> s, se | additionalA
  <- psk   | additionalB
```

##### symobf option
The symmetric obfuscation option ("symobf") allows transmission of the initiator's public ephemeral key in a manner that is indistinguishable from random to a casual observer. This indistinguishibility depends on the observer lacking knowledge of the responder's public static key, which a determined adversary may possess.

When transmitting and receiving public keys, the key material is processed through the following functions:
```
deriveObfKey(random):
  // ResponderPublicKey is known static key of peer in responder role
  return HKDF(ikm=ResponderPublicKey, len=SYM_KEY_LEN, salt=random, info="easyshare-obf")

obfuscate(pubKey):
  if(HasKey()): // HasKey() function defined in Noise Specification, Section 5.1
    return key
  random = RNG(32)
  obfKey = deriveObfKey(random)
  return random || SymmetricEncryptAEAD(key=obfKey, iv=zeros(SYM_IV_LEN), data=pubKey)

deobfuscate(inputBuffer):
  if(HasKey()):
    return inputBuffer[0 ... ASYM_PUBKEY_LEN]
  random = inputBuffer[0 ... 32]
  pubKeyCiphertext = inputBuffer[32 ... 32 + ASYM_PUBKEY_LEN]
  obfKey = deriveObfKey(random)
  return SymmetricDecryptAEAD(key=obfKey, iv=zeros(SYM_IV_LEN), data=pubKeyCiphertext)
```

##### psk4 designation
The Noise specification does not contain a "XKpsk4" pattern. This key exchange follows the standard XKpsk3 pattern, with the exception that the psk is moved to a new fourth round. This allows the responder to determine which archive ID to use for the PSK based on the initiator's request.

##### Additional key material derivation
Length obfuscation (explained below) requires the derivation of additional key material during handshaking. This is done via a modification to the `Split()` function of Noise, as defined in section 5.2 of the specification:

```
Split(): Returns a pair of CipherState objects for encrypting transport messages. Executes the following steps, where zerolen is a zero-length byte sequence:

    Sets temp_k1, temp_k2 = HKDF(ck, zerolen, 2).
    If HASHLEN is 64, then truncates temp_k1 and temp_k2 to 32 bytes.
    Creates two new CipherState objects c1 and c2.
    Calls c1.InitializeKey(temp_k1) and c2.InitializeKey(temp_k2).
    Returns the pair (c1, c2).
```

The HKDF call is changed to produce 3 outputs, the last of which is termed `akm_root`. The resulting function is termed `ModifiedSplit()` and is specified here:

```
ModifiedSplit(): Returns a pair of CipherState objects for encrypting transport messages. Executes the following steps, where zerolen is a zero-length byte sequence:

    Sets temp_k1, temp_k2, ask_root = HKDF(ck, zerolen, 3).
    If HASHLEN is 64, then truncates temp_k1 and temp_k2 to 32 bytes.
    Creates two new CipherState objects c1 and c2.
    Calls c1.InitializeKey(temp_k1) and c2.InitializeKey(temp_k2).
    Returns (c1, c2, ask_root).
```

`ask_root` is not the same kind of object as `c1` and `c2`. The purpose of this notation is simply to make clear that `ask_root` is an additional shared key calculated at the conclusion of the handshake, derived in the same HKDF operation as the key material used to create `c1` and `c2`.

##### Payloads
The additional data sections are constructed as follows.

The initiator performs the following operations to calculate `additionalA` at the end of round 3:
```
// HA refers to Noise handshake hash after the "se" symbol of round 3 has been processed
// ArchiveId is archive ID belonging to archive that initiator intends to share with responder

idHash = HMAC(HA, ArchiveId)
proofA = calculateProof(0, HA)

additionalA = JSON({ idHash:idHash, proof:proofA }) || zeros(1)
```

The responder performs the following operations to calculate `additionalB` at the end of round 4:
```
// HB refers to Noise handshake hash after the "psk" symbol of round 4 has been processed
if proofA == calculateProof(0, HA):
  proofB = calculateProof(1, HB)
else:
  proofB = RNG(SYM_KEY_LEN)
additionalB = JSON({ proof:proofB }) || zeros(1)
```

The `calculateProof` function is used by both peers:

```
calculateProof(index, hash):
  // LocalHostHasReadKey true <=> the peer executing 
  if(LocalHostHasReadKey == false):
    return RNG(SYM_KEY_LEN)
  return deriveSubkey(rootKey=PassphraseRoot, type=AUTH, name="handshake-proof:" || index || hash)
```

The `proofA` and `proofB` fields to to allow the peers to supply proof that they possess knowledge of the passphrase root key. These proofs are calculated so that the verifier must also possess knowledge of the passphrase root key to determine if they are legitimate, and are bound by way of the handshake hash to the specific connection to prevent replay attacks.

The purpose of this is to allow support for higher-level protocol messages that require each peer to have demonstrated read access to the archive contents.

### Messaging
The plaintext structure of the messages exchanged by peers is beyond the scope of this document. A given plaintext message is encrypted using the CipherState objects produced per the Noise specification. This includes authenticated encryption proving message integrity.

Messages are serialized onto the wire as follows:

```
serialize(plaintext):
  ciphertext = EncryptWithAd(zeros(0), plaintext) // Noise section 5.1, using appropriate CipherState from handshake
  Rekey() // change CipherState key after each message, see Noise section 4.2, 5.1, 11.3
  lenBytes = |ciphertext|(16)
  obfuscatedLen = obfuscateLen(LenKey, lenBytes) // see below for LenKey and obfuscatedLen definition
```

#### Ciphertext length obfuscation

The `FastHash` function is used to obfuscate the contents of length fields. This is done to prevent a casual observer from distinguishing a sample of EasySafe network traffic from random data. This obfuscation works as follows:

```
// askRoot from ModifiedHash()
initFastKeys(askRoot):
  // divide HDKF output between sipA and sipB, each of length FAST_HASH_LEN
  LenKeyA, LenKeyB = HKDF(ikm=askRoot, len=2*FAST_HASH_LEN, salt=zeros(0), info="obfuscated-length-key")
  LenIvA, LenIvB = HKDF(ikm=askRoot, len=128, salt=zeros(0), info="obfuscated-length-iv")

  // LenKeyA, LenKeyB, LenIvA, LenIvB are accessible by obfuscateLen

obfuscateLen(sentByInitiator, lenBytes):
  // we update the relevant LenIv field to ensure that `out` varies between invocations
  if sentByInitiator:
    out = LenIvA = FastHash(LenKeyA, LenIvA)
  else:
    out = LenIvB = FastHash(LenKeyB, LenIvB)
  
  return lenBytes ^ (out[0] << 8 | out[1]) // only use first 16 bits of output for XORing length field
```

# Discussion

## Argon2 parameter selection

The Argon2d variant is selected for its superior resistance to GPU and ASIC attacks. The alternatives, Argon2i and Argon2id, offer better resistance to side channel attacks. EasySafe is primarily concerned with an adversary that comes into possession of encrypted data and is able to perform offline attacks to decrypt it.

Argon2 offers a tradeoff between time and resource consumption in the form of its parallelism setting. By allowing a high degree of parallelism, a system with many cores can quickly derive a passphrase key, but must invest multiple cores to do so. There is no requirement that these threads actually run in parallel, and a single-CPU system may still perform the derivation.

As a design goal, the remaining Argon2 parameters were chosen so that a system in the 5th percentile of computing power for home users would be able to derive a passphrase key in one minute. As a further design parameter, it is assumed that such a system is likely at 75% utilization due to processes other than EasySafe.

According to the Steam Hardware and Software Survey of November 2018, over 95% of systems were reported as having at least 4GB of RAM and 2 CPUs.

The time factor was calculated by selecting the maximum number of iterations that could be performed with an average elapsed time of under 15 seconds using an Amazon t3.small instance (2 vCPU, 2GiB RAM) running a fresh installation of Ubuntu 18.04[1], as a proxy to the hypothetical 5th percentile home user with 75% load.

The following command was found to have an average completion time of 14.967 seconds, with a standard deviation of 82.37ms (n=100):

```
echo -n "landmark maggot errant ranking renewal going" | \
    time -f "%e" ./argon2 easysafe-argon2-salt -d -k 1048576 -p 16 -l 32 -e -v 13 -t 40 > /dev/null
```

\[1]: Ubuntu 18.04 was installed from the `ami-0ac019f4fcb7cb7e6` image.



### Cost analysis
To assess the security of passphrase keys against brute force attacks, we will consider the question of how long it will take for such an attack to become economically feasible to a highly capable adversary.

#### Real-world performance on high-end system
The attacker's capabilities are chosen to significantly exceed what is likely available to any present-day party. The following Amazon EC2 instance was selected as a benchmark for off-the-shelf computing power as of January 2019:

| | |
|-|-|
| Instance type | c5.18xlarge |
| vCPU | 72 |
| RAM (GiB) | 281 |
| Price | $1.1/hr [1] |

The instance was able to perform most efficiently when 9 simultaneous Argon2 processes were executed. This led to an average rate of 1.275 seconds per derivation, with a standard deviation of 42.008 milliseconds (n=900). This is equivalent to a throughput of 0.7843 passphrase key derivations per second at a price of $1.1/hr, or 2.566 kHash/$.

[1]: This is based on the lowest observed "spot rate" for the instance, reflecting the market price for unused capacity. This price is roughly equivalent to Amazon's least-expensive published means purchase this instance on a long-term basis, which is $1.104/hr. for a prepaid 3-year contract.

#### Adversary model

For the purposes of this model the following assumptions are made:

1. The adversary has a finite budget for computing key derivations.
2. The adversary can instantly compute passphrase key derivations at a rate of 26 kHash/$.
3. The cost decreases exponentially at a rate of 50% per 18 months.

We will now suppose several different passphrase classes. Each class is listed with the amount of money the adversary described in this section must spend as of 2019 to have a 50% chance of brute forcing a passphrase from that class. An adversary is guaranteed to find the passphrase with a budget of double the average cost.

| Entropy (bits) | Description                                          | Example                              | 2019 average cost
|--------|--------------------------------------------------------------|----------------------------------------------|---
| 13.280 | Random selection from 10,000 most commonly-used passwords    | letmein                                      | $0.191
| 19.930 | Random selection from 1,000,000 most commonly-used passwords | Nokia6233                                    | $19.2
| 51.700 | 4 random words, 12.925 bits entropy/word (Diceware model)    | correct horse battery staple                 | $70.3 billion
| 64.625 | 5 random words                                               | semantic defender unfold another penalize    | $547 trillion
| 77.550 | 6 random words                                               | landmark maggot errant ranking renewal going | $4.25 quintillion
| 256    | Derived key size                                             | L*YVS4}@u%i$/X%\_%^NW&hDsOXx=W{n0#.UI8.y     | $2.23 x 10^72

The 256 bit level represents an upper bound on the complexity of an adversary's attack. For some passphrase strength <= 256 bits, it becomes more economical for the adversary to attack the derived keys directly, bypassing the key derivation algorithm entirely.

The following analysis calculates the year in which an adversary will have a 50% chance of discovering the passphrase via brute force within a fixed budget in US dollars, as valued in 2019. It is expected in this model that inflation will affect the attacker's budget and cost of computing equally.

The largest listed budget is $100 trillion, roughly equivalent to the present global GDP. This is chosen as an upper bound on the budget of any adversary. The minimum budget is $0.001. This is chosen as a point where the cost of brute forcing the passphrase is truly negligible, and the adversary may become indifferent as to whether the archive had been unencrypted in the first place. This threshold is not easy to define objectively, and it is also unclear when storage costs will make a rainbow table economical for each passphrase class.

| Entropy (bits) | $0.001 | $1   | $1,000 | $1 million | $1 billion | $100 trillion
|----------------|--------|------|--------|------------|------------|---------------
| 13.280         | 2030   | Now  | Now    | Now        | Now        | Now
| 19.930         | 2040   | 2025 | Now    | Now        | Now        | Now
| 51.700         | 2088   | 2073 | 2058   | 2043       | 2028       | Now
| 64.625         | 2107   | 2092 | 2077   | 2062       | 2047       | 2027
| 77.550         | 2126   | 2111 | 2096   | 2081       | 2066       | 2047
| 256            | 2394   | 2379 | 2364   | 2349       | 2334       | 2314

##### Rainbow tables
An attacker has the option of maintaining a "rainbow table" storing the keys derived from every possible passphrase in a class. They could then attempt any of their cached passphrases with a negligible time or computing cost compared to the cost of the key derivation function. An attacker must still conduct an initial brute force attack and store the results, which is impractical for sufficiently-strong passphrases. For weaker passphrases, this option is economical.

If each row of the table had a 256-bit identifier based on the passphrase, and the derived key, then the 2^19.93 level would require 256MiB in storage, and cost the modeled adversary approximately $38.40 to compute.

##### Overestimate of adversary capabilities
The above model is presented to provide an estimate for the minimum duration EasySafe can resist brute force attacks against the passphrase. The model assumes an exponential reduction of cost by 50% every 18 months, which may not be sustainable due to limitations imposed by, among other things, the laws of thermodynamics.

Bruce Schneier points out in Applied Cryptography that if the energy of a typical supernova could be dedicated to computation in an idealized system operating with maximum theoretical efficiency at the average temperature of the universe, then that system could count to approximately 2^219. This is several hundred billion times less expensive than counting to 2^256. This does not account for any of the energy needed to perform any calculations with this counter.

The prediction that the adversary will have access to billions of supernovas worth of energy for the present-day value of $0.001 suggests that the model strongly overestimates the adversary's capabilities.

##### Inadequacy of ordinary passphrases
Weak passphrase selection is an ongoing problem in information security. Even given a key derivation function that is extremely expensive by current standards, the most commonly-used passwords are economical to attack even today. Users must select passphrases much stronger than what is typically selected today for EasySafe to provide a reasonable assurance of confidentiality.

## Threat model

### Basic model
The basic threat model refers to an adversary with strong capabilities, including knowledge of keys used for data-in-transit. Additional threat models will consider additional guarantees that can be made when an adversary possesses fewer capabilities. The basic threat model is intended to consider the security guarantees offered by the file system, disregarding any network-level security.

#### Basic adversary capabilities

The basic adversary is assumed to possess...

1. ...the ability to view, alter, extend, truncate, create and/or drop any packet sent to or from any EasySafe peer.
1. ...the ability to view, alter, extend, truncate, create and/or delete any file directly created by EasySafe on any host filesystem anywhere in realtime.\[1]
2. ...knowledge of the contents of every file directly created by EasySafe on any host filesystem at any point in history.
1. ...knowledge of the archive's seed key and archive ID
1. ...knowledge of the version and full source code of any EasySafe application running on any peer
2. ...knowledge of all key material used to encrypt network communications, including static keypairs, ephemeral keypairs, preshared secrets and any keys derived from aforementioned material.\[2]
3. ...knowledge of the identities of each peer
4. ...access to the `InodeTableOracle` function, by which the adversary can at no cost identify inode table pages to attack.
5. ...access to the `SuperPageEncryptionOracle` function, by which the adversary can at no cost craft arbitrary properly-encoded pages with arbitrary plaintext.
6. ...access to the `SuperPageTreeChunkEncryptionOracle` function, by which the adversary can at no cost craft arbitrary properly-encoded page tree chunks with arbitrary plaintext.
5. ...the ability to perform `PBKDF` operations with no cost.

##### Oracle definitions

```
// tag: Tag of an encrypted page/page tree chunk/config file
// contents: Literal text of the encrypted file
InodeTableOracle(tag, contents):
  isInodeTable // set true <=> the file represents the contents of a page of the inode table
  pageNum // set to page number of this inode table page if isInodeTable, else undefined
  refTag // set to the refTag of the inode table this page belongs to if isInodeTable, else undefined
  return [isInodeTable, refTag, pageNum]

// allow adversary to craft an arbitrary page as if it has knowledge of all needed keys, and also force IV selection
SuperPageEncryptionOracle(inodeIdentifier, pageNum, iv, pageText):
  tweak = inodeIdentity(64) || pageNum(64)
  pageSymKey = deriveSubkey(rootKey=ArchiveRoot, type=CIPHER, name="page:" || tweak)
  pageAuthKey = deriveSubkey(rootKey=SeedRoot, type=AUTH, name="page:" || tweak)
  
  // The adversary of this model is allowed to override the IV in taggedEncrypt, making it deterministic.
  return taggedEncrypt(symKey=chunkSymKey, authKey=chunkAuthKey, signPrivateKey=WritePrivateKey, iv=iv, plaintext=pageText)

// allow adversary to craft an arbitrary page tree chunk as if it has knowledge of all needed keys, and also force IV selection
SuperPageTreeChunkEncryptionOracle(inodeIdentifier, chunkNum, iv, chunkText):
  tweak = inodeIdentity(64) || chunkNum(64)
  chunkSymKey = deriveSubkey(rootKey=ArchiveRoot, type=CIPHER, name="chunk:" || tweak)
  chunkAuthKey = deriveSubkey(rootKey=SeedRoot, type=AUTH, name="chunk:" || tweak)
  
  // The adversary of this model is allowed to override the IV in taggedEncrypt, making it deterministic.
  return taggedEncrypt(symKey=chunkSymKey, authKey=chunkAuthKey, signPrivateKey=WritePrivateKey, iv=iv, plaintext=chunkText)
```

\[1]: This does not extend to virtual memory dumps that may include sensitive key material. Nothing in this threat model should be taken to indicate that EasySafe provides security against an adversary with physical or privileged access to a peer's system while EasySafe is in operation.

\[2]: This does not apply to key material related to the filesystem. Specifically, the basic adversary does not have knowledge of the passphrase, passphrase root, archive root, or any keys derived from this material.

##### Basic adversary limitations

The adversary's capabilities are limited to those things listed above. The following non-comprehensive list of limitations is provided to minimize confusion.

The adversary does not possess...

1. ...advance knowledge of the passphrase, write key or archive root.
2. ...the ability to read the contents of EasySafe's memory.
3. ...a technique for attacking any of the cryptographic primitives in less average time than a brute force attack.
4. ...information about the archive other than what is stated in the definition, written to disk or sent over the network. The adversary has knowledge of the sequence of operations, but not their exact timing.[3]

\[3] In reality, even casual observers almost certainly possess information about timing. Real adversaries may also possess other information such as sound, power utilization or EM radiation, any of which could enable a side channel attack. This restriction is intended to exclude matters of implementation and physical security from the analysis.

#### Basic archive assumptions

The following assumptions are made of the structure of the archive.

1. The passphrase key contains K bits of entropy, K <= 256.
2. The archive has P files containing pages or page tree chunks unrelated to the inode table.
3. Any page within the archive possesses a minimum of F bits of entropy.

#### Basic security levels
EasySafe provides the following guarantees against the basic adversary. The adversary faces the following complexities:

TODO: Sketch out algorithm/proof for each attack to show complexity, put online, provide link here.

| Task                                              | Minimum complexity (log 2) | Notes    |
|---------------------------------------------------|--------------------|----------|
| Delete data from an archive                  | 0 | The adversary can delete arbitrary pages from all peers, but does not have knowledge of what is being deleted beyond whether it is an inode table without performing a separate and more costly attack.
| Insert data into an archive | K | The adversary can craft fake data using the `SuperPageEncryptionOracle` function, but cannot craft a fake RevisionTag.
| Determine authorship of encrypted page            | 0 | Adversary has capability to observe first peer to transmit page
| Determine the contents of a page in the archive | (64 + F)\[1]      | Adversary brute forces guesses of file contents and `inodeIdentity` through `SuperPageEncryptionOracle`
| Determine the number of files in the archive | 0\[2] | Adversary can learn approximate number based on inode table size, learned through `InodeTableOracle`. |
| Determine when a file is unlinked from the archive filesystem | (64 + F)\[1,3,4] | Best known option is brute force of root directory, assuming file is in root directory (worst case)
| Determine the specific size of a file in the archive | K[3] | Other than traffic analysis[3], best known option is brute force attack on inode table
| Determine names of files within archives | (64 + F)\[1,4] | Brute force of root directory
| Determine `stat_t`-like metadata concerning a file in the archive | K | Best known option is brute force attack on inode table
| Determine whether a given file is in the archive | (64 + P)\[1] | Adversary combines `SuperPageEncryptionOracle` with a brute-force attack on 64-bit inodeIdentity against the IVs of each page observed in the archive


\[1]: or K, if K is lesser.
\[2]: Adversary learns approximate number, and not exact figure.
\[3]: The adversary may be able to infer this information by observing how often certain pages are downloaded. These patterns vary depending on use case.

### Restricted model
The restricted threat model refers to an adversary whose capabilities are more limited compared to the basic model, with the following capability differences:

#### Restricted adversary capabilities

The restricted adversary possesses...

1. ...the ability to view, alter, extend, truncate, create and/or drop any packet sent to or from any EasySafe peer.
1. ...a copy of all data written to the EasySafe archive in encrypted form.
1. ...knowledge of the archive's seed key and archive ID
1. ...knowledge of the version and full source code of any EasySafe application running on any peer
4. ...access to the `InodeTableOracle` function, by which the adversary can at no cost identify inode table pages to attack.
5. ...access to the `PageEncryptionOracle` function, by which the adversary can at no cost craft arbitrary properly-encoded pages with arbitrary plaintext.
6. ...access to the `PageTreeChunkEncryptionOracle` function, by which the adversary can at no cost craft arbitrary properly-encoded page tree chunks with arbitrary plaintext.
5. ...the ability to perform `PBKDF` operations with no cost.

#### Restricted adversary limitations

The restricted adversary has the same limitations as the basic adversary.

#### Restricted model security levels

TODO: Sketch out algorithm/proof for each attack to show complexity.

| Task                                              | Complexity (log 2) | Notes    |
|---------------------------------------------------|--------------------|----------|
| Delete data from an archive                  | N/A | The adversary cannot delete data from peer storage, and all existing files are immutable by design.
| Insert data into an archive | K | The adversary can craft fake data using the `PageEncryptionOracle` function, but cannot craft a fake RevisionTag.
| Determine authorship of encrypted page[3]            | N/A | 
| Determine the contents of a page in the archive | K      | 
| Determine the number of files in the archive | 0 | Adversary can learn approximate number based on inode table size, learned through `InodeTableOracle`.
| Determine when a file is unlinked from the archive filesystem | K | 
| Determine the approximate size of a file in the archive | K[3] | Other than traffic analysis[3], best known option is brute force attack on inode table
| Determine names of files within archives | K | 
| Determine `stat_t`-like metadata concerning a file in the archive | K | Best known option is brute force attack on inode table
| Determine whether a given file is in the archive | K | 


\[1]: or K, if K is lesser.
\[2]: Adversary learns approximate number, and not exact figure.
\[3]: The adversary may be able to infer this information by acting as a seed and noting patterns in the upload and download of pages. These patterns vary depending on use case, and the adversary must be online as a seed to perform this method.

## Rationales

### Why not use JSON for the config file?
Using JSON would mean that archive IDs would not follow deterministically from passphrases for default archives, since JSON does not guarantee a unique serialization for a given object.

### Why encode the archive config tag and page length in the archive ID?
Peers receiving an archive for the first time need certain bootstrap info. The swarm protocol relies on parties agreeing on page size in advance. Although this is in the archive config, the archive config itself must be transmitted through the protocol. By encoding the page size directly into the ID, naive peers can immediately join in the swarm. By also basing the ID on the config tag, the configuration file can be validated to prove that it corresponds to the intended archive ID.

### Why use the "symobf" option instead of something like Elligator2?
As of this writing, Elligator2 support is difficult to find. The symobf technique is similar to the methodology used in the i2p project's NTCP2 protocol.

### Why not use ephemeral keys for the DHT protocol?
The DHT protocol is stateless, and also very size constrained. At present, DHT messages are limited to a maximum size of 508 bytes. Using an ephemeral key would consume additional space in the packet, and require a significant increase in the CPU load created by the protocol due to the extra Diffie-Hellman operation.

### What is the purpose of encrypting RevisionTags?
Seed peers must be able to receive RevisionTags so they can be relayed to read-access peers. If the revision tags were not encrypted, the seed peers would gain unnecessary insight into the structure of the archive.

### Why does taggedEncrypt do encrypt-then-MAC instead of an AEAD cipher?
The resulting tag would not be verifiable by seed peers, who do not possess the symmetric key used to produce the ciphertext. The MAC is calculated using a key derived from the seed root. Using an AEAD cipher in addition to this MAC would be an additional CPU cost, when authenticity and integrity are already guaranteed.

### Why does taggedEncrypt use both an encrypt-then-MAC hash and an asymmetric signature?
A peer processing an incoming page or chunk must be able to provde three things, using knowledge of the seed key and public write key:

1. The text has not been tampered with.
2. The text was created by someone with knowledge of the private write key.
3. The text belongs to this archive, and not another archive that the write key may have been used for.

The asymmetric signature proves both 1) and 2), whereas the authenticated hash proves 1) and 3). Furthermore, the authenticated hash can be validated much more quickly, offering a reduced-cost way to perform integrity checking over a large batch of data.

### Why not support de-duplication?
The use of page- and inode-specific derived keys with random salts provides resistance against the chosen plaintext capabilities granted in the threat models (e.g. `PageEncryptionOracle`).

Later versions may support page-independent keys with deterministic IVs as an option for users who desire de-duplication.

### What if I want to revoke someone's access to an archive, or change the passphrase?
Archive passwords are immutable. One option is to migrate the data in the archive to one with a new passphrase. This passphrase would then need to be distributed to the authorized parties. The means for doing this are beyond the scope of this document.

### Isn't this really great for bad people?
Cryptography lets people talk and do business, even in the presence of adversaries. It's terrible for bad people on principle. EasySafe in particular is not a secure option for organized crime or terror, since all the security depends on a single unchangable passphrase. If any member of the group disclosed that passphrase, law enforcement would then be able to see the IP addresses of peers as well as the content of the archive.

It is also much harder to destroy the evidence of possessing an encrypted file. Encrypted data appears statistically random, and so a given encrypted file can be uniquely identified by just a few bytes taken from anywhere in the file. If someone tried to use EasySafe to conceal possession of unlawful material, they may actually be increasing their chances of conviction.

Law enforcement and intelligence agencies also possess access to numerous side channel attacks, all of which are beyond the scope of EasySafe's security model.